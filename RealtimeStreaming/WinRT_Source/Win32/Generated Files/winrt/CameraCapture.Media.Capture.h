// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180227.3

#pragma once
#include "winrt/base.h"

WINRT_WARNING_PUSH

static_assert(winrt::check_version(CPPWINRT_VERSION, "1.0.180227.3"), "Mismatched component and base headers.");
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Media.Capture.2.h"
#include "winrt/impl/Windows.Media.MediaProperties.2.h"
#include "winrt/impl/Windows.Media.2.h"
#include "winrt/impl/Windows.Media.Effects.2.h"
#include "winrt/impl/CameraCapture.Media.Capture.2.h"

namespace winrt::impl {

template <typename D> Windows::Media::MediaProperties::AudioEncodingProperties consume_CameraCapture_Media_Capture_IAudioPayload<D>::AudioProperties() const
{
    Windows::Media::MediaProperties::AudioEncodingProperties result{ nullptr };
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IAudioPayload)->get_AudioProperties(put_abi(result)));
    return result;
}

template <typename D> CameraCapture::Media::Capture::AudioMixerMode consume_CameraCapture_Media_Capture_IMrcAudioEffect<D>::MixerMode() const
{
    CameraCapture::Media::Capture::AudioMixerMode result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcAudioEffect)->get_MixerMode(put_abi(result)));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IMrcAudioEffect<D>::MixerMode(CameraCapture::Media::Capture::AudioMixerMode const& value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcAudioEffect)->put_MixerMode(get_abi(value)));
}

template <typename D> float consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::GlobalOpacityCoefficient() const
{
    float result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->get_GlobalOpacityCoefficient(&result));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::GlobalOpacityCoefficient(float value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->put_GlobalOpacityCoefficient(value));
}

template <typename D> bool consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::HologramCompositionEnabled() const
{
    bool result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->get_HologramCompositionEnabled(&result));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::HologramCompositionEnabled(bool value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->put_HologramCompositionEnabled(value));
}

template <typename D> bool consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::RecordingIndicatorEnabled() const
{
    bool result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->get_RecordingIndicatorEnabled(&result));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::RecordingIndicatorEnabled(bool value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->put_RecordingIndicatorEnabled(value));
}

template <typename D> Windows::Media::Capture::MediaStreamType consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::StreamType() const
{
    Windows::Media::Capture::MediaStreamType result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->get_StreamType(put_abi(result)));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::StreamType(Windows::Media::Capture::MediaStreamType const& value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->put_StreamType(get_abi(value)));
}

template <typename D> bool consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::VideoStabilizationEnabled() const
{
    bool result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->get_VideoStabilizationEnabled(&result));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::VideoStabilizationEnabled(bool value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->put_VideoStabilizationEnabled(value));
}

template <typename D> uint32_t consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::VideoStabilizationBufferLength() const
{
    uint32_t result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->get_VideoStabilizationBufferLength(&result));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::VideoStabilizationBufferLength(uint32_t value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->put_VideoStabilizationBufferLength(value));
}

template <typename D> uint32_t consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>::VideoStabilizationMaximumBufferLength() const
{
    uint32_t result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IMrcVideoEffect)->get_VideoStabilizationMaximumBufferLength(&result));
    return result;
}

template <typename D> Windows::Media::MediaProperties::IMediaEncodingProperties consume_CameraCapture_Media_Capture_IPayload<D>::MediaEncodingProperties() const
{
    Windows::Media::MediaProperties::IMediaEncodingProperties result{ nullptr };
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IPayload)->get_MediaEncodingProperties(put_abi(result)));
    return result;
}

template <typename D> HRESULT consume_CameraCapture_Media_Capture_IPayloadHandler<D>::QueuePayload(CameraCapture::Media::Capture::Payload const& payload) const
{
    HRESULT result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IPayloadHandler)->QueuePayload(get_abi(payload), put_abi(result)));
    return result;
}

template <typename D> event_token consume_CameraCapture_Media_Capture_IPayloadHandler<D>::OnSample(Windows::Foundation::EventHandler<CameraCapture::Media::Capture::Payload> const& handler) const
{
    event_token token{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IPayloadHandler)->add_OnSample(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> event_revoker<CameraCapture::Media::Capture::IPayloadHandler> consume_CameraCapture_Media_Capture_IPayloadHandler<D>::OnSample(auto_revoke_t, Windows::Foundation::EventHandler<CameraCapture::Media::Capture::Payload> const& handler) const
{
    return impl::make_event_revoker<D, CameraCapture::Media::Capture::IPayloadHandler>(this, &abi_t<CameraCapture::Media::Capture::IPayloadHandler>::remove_OnSample, OnSample(handler));
}

template <typename D> void consume_CameraCapture_Media_Capture_IPayloadHandler<D>::OnSample(event_token const& token) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IPayloadHandler)->remove_OnSample(get_abi(token)));
}

template <typename D> HRESULT consume_CameraCapture_Media_Capture_ISink<D>::OnEndOfStream() const
{
    HRESULT result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::ISink)->OnEndOfStream(put_abi(result)));
    return result;
}

template <typename D> CameraCapture::Media::Capture::State consume_CameraCapture_Media_Capture_ISink<D>::State() const
{
    CameraCapture::Media::Capture::State result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::ISink)->get_State(put_abi(result)));
    return result;
}

template <typename D> CameraCapture::Media::Capture::PayloadHandler consume_CameraCapture_Media_Capture_ISink<D>::PayloadHandler() const
{
    CameraCapture::Media::Capture::PayloadHandler result{ nullptr };
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::ISink)->get_PayloadHandler(put_abi(result)));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_ISink<D>::PayloadHandler(CameraCapture::Media::Capture::PayloadHandler const& value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::ISink)->put_PayloadHandler(get_abi(value)));
}

template <typename D> CameraCapture::Media::Capture::Sink consume_CameraCapture_Media_Capture_ISinkFactory<D>::CreateInstance(Windows::Media::MediaProperties::MediaEncodingProfile const& encodingProfile) const
{
    CameraCapture::Media::Capture::Sink value{ nullptr };
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::ISinkFactory)->CreateInstance(get_abi(encodingProfile), put_abi(value)));
    return value;
}

template <typename D> HRESULT consume_CameraCapture_Media_Capture_IStreamSink<D>::Start(int64_t systemTime, int64_t clockStartOffset) const
{
    HRESULT result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IStreamSink)->Start(systemTime, clockStartOffset, put_abi(result)));
    return result;
}

template <typename D> HRESULT consume_CameraCapture_Media_Capture_IStreamSink<D>::Stop() const
{
    HRESULT result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IStreamSink)->Stop(put_abi(result)));
    return result;
}

template <typename D> HRESULT consume_CameraCapture_Media_Capture_IStreamSink<D>::Shutdown() const
{
    HRESULT result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IStreamSink)->Shutdown(put_abi(result)));
    return result;
}

template <typename D> CameraCapture::Media::Capture::State consume_CameraCapture_Media_Capture_IStreamSink<D>::State() const
{
    CameraCapture::Media::Capture::State result{};
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IStreamSink)->get_State(put_abi(result)));
    return result;
}

template <typename D> void consume_CameraCapture_Media_Capture_IStreamSink<D>::State(CameraCapture::Media::Capture::State const& value) const
{
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IStreamSink)->put_State(get_abi(value)));
}

template <typename D> CameraCapture::Media::Capture::StreamSink consume_CameraCapture_Media_Capture_IStreamSinkFactory<D>::CreateInstance(uint8_t index, Windows::Media::MediaProperties::IMediaEncodingProperties const& encodingProperties, CameraCapture::Media::Capture::Sink const& parent) const
{
    CameraCapture::Media::Capture::StreamSink value{ nullptr };
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IStreamSinkFactory)->CreateInstance(index, get_abi(encodingProperties), get_abi(parent), put_abi(value)));
    return value;
}

template <typename D> Windows::Media::MediaProperties::VideoEncodingProperties consume_CameraCapture_Media_Capture_IVideoPayload<D>::VideoProperties() const
{
    Windows::Media::MediaProperties::VideoEncodingProperties result{ nullptr };
    check_hresult(WINRT_SHIM(CameraCapture::Media::Capture::IVideoPayload)->get_VideoProperties(put_abi(result)));
    return result;
}

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IAudioPayload> : produce_base<D, CameraCapture::Media::Capture::IAudioPayload>
{
    HRESULT __stdcall get_AudioProperties(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Media::MediaProperties::AudioEncodingProperties>(this->shim().AudioProperties());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IMrcAudioEffect> : produce_base<D, CameraCapture::Media::Capture::IMrcAudioEffect>
{
    HRESULT __stdcall get_MixerMode(CameraCapture::Media::Capture::AudioMixerMode* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<CameraCapture::Media::Capture::AudioMixerMode>(this->shim().MixerMode());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_MixerMode(CameraCapture::Media::Capture::AudioMixerMode value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MixerMode(*reinterpret_cast<CameraCapture::Media::Capture::AudioMixerMode const*>(&value));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IMrcVideoEffect> : produce_base<D, CameraCapture::Media::Capture::IMrcVideoEffect>
{
    HRESULT __stdcall get_GlobalOpacityCoefficient(float* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<float>(this->shim().GlobalOpacityCoefficient());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_GlobalOpacityCoefficient(float value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GlobalOpacityCoefficient(value);
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_HologramCompositionEnabled(bool* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().HologramCompositionEnabled());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_HologramCompositionEnabled(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HologramCompositionEnabled(value);
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_RecordingIndicatorEnabled(bool* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().RecordingIndicatorEnabled());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_RecordingIndicatorEnabled(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RecordingIndicatorEnabled(value);
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_StreamType(Windows::Media::Capture::MediaStreamType* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Media::Capture::MediaStreamType>(this->shim().StreamType());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_StreamType(Windows::Media::Capture::MediaStreamType value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StreamType(*reinterpret_cast<Windows::Media::Capture::MediaStreamType const*>(&value));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_VideoStabilizationEnabled(bool* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().VideoStabilizationEnabled());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_VideoStabilizationEnabled(bool value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VideoStabilizationEnabled(value);
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_VideoStabilizationBufferLength(uint32_t* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().VideoStabilizationBufferLength());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_VideoStabilizationBufferLength(uint32_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VideoStabilizationBufferLength(value);
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_VideoStabilizationMaximumBufferLength(uint32_t* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().VideoStabilizationMaximumBufferLength());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IPayload> : produce_base<D, CameraCapture::Media::Capture::IPayload>
{
    HRESULT __stdcall get_MediaEncodingProperties(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Media::MediaProperties::IMediaEncodingProperties>(this->shim().MediaEncodingProperties());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IPayloadFactory> : produce_base<D, CameraCapture::Media::Capture::IPayloadFactory>
{};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IPayloadHandler> : produce_base<D, CameraCapture::Media::Capture::IPayloadHandler>
{
    HRESULT __stdcall QueuePayload(void* payload, HRESULT* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<HRESULT>(this->shim().QueuePayload(*reinterpret_cast<CameraCapture::Media::Capture::Payload const*>(&payload)));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall add_OnSample(void* handler, event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *token = detach_from<event_token>(this->shim().OnSample(*reinterpret_cast<Windows::Foundation::EventHandler<CameraCapture::Media::Capture::Payload> const*>(&handler)));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall remove_OnSample(event_token token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OnSample(*reinterpret_cast<event_token const*>(&token));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::ISink> : produce_base<D, CameraCapture::Media::Capture::ISink>
{
    HRESULT __stdcall OnEndOfStream(HRESULT* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<HRESULT>(this->shim().OnEndOfStream());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_State(CameraCapture::Media::Capture::State* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<CameraCapture::Media::Capture::State>(this->shim().State());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_PayloadHandler(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            *result = detach_from<CameraCapture::Media::Capture::PayloadHandler>(this->shim().PayloadHandler());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_PayloadHandler(void* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().PayloadHandler(*reinterpret_cast<CameraCapture::Media::Capture::PayloadHandler const*>(&value));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::ISinkFactory> : produce_base<D, CameraCapture::Media::Capture::ISinkFactory>
{
    HRESULT __stdcall CreateInstance(void* encodingProfile, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            *value = detach_from<CameraCapture::Media::Capture::Sink>(this->shim().CreateInstance(*reinterpret_cast<Windows::Media::MediaProperties::MediaEncodingProfile const*>(&encodingProfile)));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IStreamSink> : produce_base<D, CameraCapture::Media::Capture::IStreamSink>
{
    HRESULT __stdcall Start(int64_t systemTime, int64_t clockStartOffset, HRESULT* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<HRESULT>(this->shim().Start(systemTime, clockStartOffset));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall Stop(HRESULT* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<HRESULT>(this->shim().Stop());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall Shutdown(HRESULT* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<HRESULT>(this->shim().Shutdown());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall get_State(CameraCapture::Media::Capture::State* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<CameraCapture::Media::Capture::State>(this->shim().State());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }

    HRESULT __stdcall put_State(CameraCapture::Media::Capture::State value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().State(*reinterpret_cast<CameraCapture::Media::Capture::State const*>(&value));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IStreamSinkFactory> : produce_base<D, CameraCapture::Media::Capture::IStreamSinkFactory>
{
    HRESULT __stdcall CreateInstance(uint8_t index, void* encodingProperties, void* parent, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            *value = detach_from<CameraCapture::Media::Capture::StreamSink>(this->shim().CreateInstance(index, *reinterpret_cast<Windows::Media::MediaProperties::IMediaEncodingProperties const*>(&encodingProperties), *reinterpret_cast<CameraCapture::Media::Capture::Sink const*>(&parent)));
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

template <typename D>
struct produce<D, CameraCapture::Media::Capture::IVideoPayload> : produce_base<D, CameraCapture::Media::Capture::IVideoPayload>
{
    HRESULT __stdcall get_VideoProperties(void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Media::MediaProperties::VideoEncodingProperties>(this->shim().VideoProperties());
            return S_OK;
        }
        catch (...)
        {
            return to_hresult();
        }
    }
};

}

WINRT_EXPORT namespace winrt::CameraCapture::Media::Capture {

inline AudioPayload::AudioPayload() :
    AudioPayload(get_activation_factory<AudioPayload>().ActivateInstance<AudioPayload>())
{}

inline MrcAudioEffect::MrcAudioEffect() :
    MrcAudioEffect(get_activation_factory<MrcAudioEffect>().ActivateInstance<MrcAudioEffect>())
{}

inline MrcVideoEffect::MrcVideoEffect() :
    MrcVideoEffect(get_activation_factory<MrcVideoEffect>().ActivateInstance<MrcVideoEffect>())
{}

inline PayloadHandler::PayloadHandler() :
    PayloadHandler(get_activation_factory<PayloadHandler>().ActivateInstance<PayloadHandler>())
{}

inline Sink::Sink(Windows::Media::MediaProperties::MediaEncodingProfile const& encodingProfile) :
    Sink(get_activation_factory<Sink, CameraCapture::Media::Capture::ISinkFactory>().CreateInstance(encodingProfile))
{}

inline StreamSink::StreamSink(uint8_t index, Windows::Media::MediaProperties::IMediaEncodingProperties const& encodingProperties, CameraCapture::Media::Capture::Sink const& parent) :
    StreamSink(get_activation_factory<StreamSink, CameraCapture::Media::Capture::IStreamSinkFactory>().CreateInstance(index, encodingProperties, parent))
{}

inline VideoPayload::VideoPayload() :
    VideoPayload(get_activation_factory<VideoPayload>().ActivateInstance<VideoPayload>())
{}

}

WINRT_EXPORT namespace std {

template<> struct hash<winrt::CameraCapture::Media::Capture::IAudioPayload> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IAudioPayload> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IMrcAudioEffect> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IMrcAudioEffect> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IMrcVideoEffect> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IMrcVideoEffect> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IPayload> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IPayload> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IPayloadFactory> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IPayloadFactory> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IPayloadHandler> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IPayloadHandler> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::ISink> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::ISink> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::ISinkFactory> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::ISinkFactory> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IStreamSink> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IStreamSink> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IStreamSinkFactory> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IStreamSinkFactory> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::IVideoPayload> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::IVideoPayload> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::AudioPayload> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::AudioPayload> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::MrcAudioEffect> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::MrcAudioEffect> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::MrcVideoEffect> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::MrcVideoEffect> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::Payload> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::Payload> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::PayloadHandler> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::PayloadHandler> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::Sink> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::Sink> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::StreamSink> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::StreamSink> {};
template<> struct hash<winrt::CameraCapture::Media::Capture::VideoPayload> : winrt::impl::hash_base<winrt::CameraCapture::Media::Capture::VideoPayload> {};

}

WINRT_WARNING_POP
