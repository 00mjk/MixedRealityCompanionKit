// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180821.2

#pragma once

#include "winrt/base.h"


static_assert(winrt::check_version(CPPWINRT_VERSION, "1.0.180821.2"), "Mismatched component and base headers.");
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/impl/RealtimeStreaming.Common.2.h"
#include "winrt/impl/Windows.Networking.Sockets.2.h"
#include "winrt/impl/RealtimeStreaming.Plugin.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/RealtimeStreaming.Network.2.h"

namespace winrt::impl {

template <typename D> Windows::Foundation::IAsyncAction consume_RealtimeStreaming_Network_IConnection<D>::SendPayloadTypeAsync(RealtimeStreaming::Common::PayloadType const& type) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnection)->SendPayloadTypeAsync(get_abi(type), put_abi(operation)));
    return operation;
}

template <typename D> Windows::Foundation::IAsyncAction consume_RealtimeStreaming_Network_IConnection<D>::SendBundleAsync(RealtimeStreaming::Network::DataBundle const& dataBundle) const
{
    Windows::Foundation::IAsyncAction operation{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnection)->SendBundleAsync(get_abi(dataBundle), put_abi(operation)));
    return operation;
}

template <typename D> bool consume_RealtimeStreaming_Network_IConnection<D>::IsConnected() const
{
    bool value{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnection)->get_IsConnected(&value));
    return value;
}

template <typename D> Windows::Networking::Sockets::StreamSocketInformation consume_RealtimeStreaming_Network_IConnection<D>::ConnectionInfo() const
{
    Windows::Networking::Sockets::StreamSocketInformation value{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnection)->get_ConnectionInfo(put_abi(value)));
    return value;
}

template <typename D> winrt::event_token consume_RealtimeStreaming_Network_IConnection<D>::Disconnected(RealtimeStreaming::Network::DisconnectedDelegate const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnection)->add_Disconnected(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_RealtimeStreaming_Network_IConnection<D>::Disconnected_revoker consume_RealtimeStreaming_Network_IConnection<D>::Disconnected(auto_revoke_t, RealtimeStreaming::Network::DisconnectedDelegate const& handler) const
{
    return impl::make_event_revoker<D, Disconnected_revoker>(this, Disconnected(handler));
}

template <typename D> void consume_RealtimeStreaming_Network_IConnection<D>::Disconnected(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(RealtimeStreaming::Network::IConnection)->remove_Disconnected(get_abi(token)));
}

template <typename D> winrt::event_token consume_RealtimeStreaming_Network_IConnection<D>::Received(Windows::Foundation::EventHandler<RealtimeStreaming::Network::DataBundleArgs> const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnection)->add_Received(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_RealtimeStreaming_Network_IConnection<D>::Received_revoker consume_RealtimeStreaming_Network_IConnection<D>::Received(auto_revoke_t, Windows::Foundation::EventHandler<RealtimeStreaming::Network::DataBundleArgs> const& handler) const
{
    return impl::make_event_revoker<D, Received_revoker>(this, Received(handler));
}

template <typename D> void consume_RealtimeStreaming_Network_IConnection<D>::Received(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(RealtimeStreaming::Network::IConnection)->remove_Received(get_abi(token)));
}

template <typename D> RealtimeStreaming::Network::Connection consume_RealtimeStreaming_Network_IConnectionFactory<D>::CreateInstance(Windows::Networking::Sockets::StreamSocket const& streamSocket) const
{
    RealtimeStreaming::Network::Connection value{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnectionFactory)->CreateInstance(get_abi(streamSocket), put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> consume_RealtimeStreaming_Network_IConnector<D>::ConnectAsync() const
{
    Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> operation{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnector)->ConnectAsync(put_abi(operation)));
    return operation;
}

template <typename D> winrt::event_token consume_RealtimeStreaming_Network_IConnector<D>::Closed(Windows::Foundation::EventHandler<bool> const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IConnector)->add_Closed(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_RealtimeStreaming_Network_IConnector<D>::Closed_revoker consume_RealtimeStreaming_Network_IConnector<D>::Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const
{
    return impl::make_event_revoker<D, Closed_revoker>(this, Closed(handler));
}

template <typename D> void consume_RealtimeStreaming_Network_IConnector<D>::Closed(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(RealtimeStreaming::Network::IConnector)->remove_Closed(get_abi(token)));
}

template <typename D> uint64_t consume_RealtimeStreaming_Network_IDataBuffer<D>::CurrentLength() const
{
    uint64_t value{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBuffer)->get_CurrentLength(&value));
    return value;
}

template <typename D> void consume_RealtimeStreaming_Network_IDataBuffer<D>::CurrentLength(uint64_t value) const
{
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBuffer)->put_CurrentLength(value));
}

template <typename D> uint64_t consume_RealtimeStreaming_Network_IDataBuffer<D>::Offset() const
{
    uint64_t value{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBuffer)->get_Offset(&value));
    return value;
}

template <typename D> void consume_RealtimeStreaming_Network_IDataBuffer<D>::Offset(uint64_t value) const
{
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBuffer)->put_Offset(value));
}

template <typename D> void consume_RealtimeStreaming_Network_IDataBuffer<D>::TrimLeft(uint64_t cbSize) const
{
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBuffer)->TrimLeft(cbSize));
}

template <typename D> RealtimeStreaming::Network::DataBuffer consume_RealtimeStreaming_Network_IDataBuffer<D>::TrimRight(uint64_t cbSize) const
{
    RealtimeStreaming::Network::DataBuffer result{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBuffer)->TrimRight(cbSize, put_abi(result)));
    return result;
}

template <typename D> void consume_RealtimeStreaming_Network_IDataBuffer<D>::Reset() const
{
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBuffer)->Reset());
}

template <typename D> RealtimeStreaming::Network::DataBuffer consume_RealtimeStreaming_Network_IDataBufferFactory<D>::CreateInstance(uint64_t size) const
{
    RealtimeStreaming::Network::DataBuffer value{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBufferFactory)->CreateInstance(size, put_abi(value)));
    return value;
}

template <typename D> uint32_t consume_RealtimeStreaming_Network_IDataBundle<D>::BufferCount() const
{
    uint32_t value{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundle)->get_BufferCount(&value));
    return value;
}

template <typename D> uint64_t consume_RealtimeStreaming_Network_IDataBundle<D>::TotalSize() const
{
    uint64_t value{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundle)->get_TotalSize(&value));
    return value;
}

template <typename D> void consume_RealtimeStreaming_Network_IDataBundle<D>::AddBuffer(RealtimeStreaming::Network::DataBuffer const& dataBuffer) const
{
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundle)->AddBuffer(get_abi(dataBuffer)));
}

template <typename D> bool consume_RealtimeStreaming_Network_IDataBundle<D>::InsertBuffer(uint32_t index, RealtimeStreaming::Network::DataBuffer const& dataBuffer) const
{
    bool result{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundle)->InsertBuffer(index, get_abi(dataBuffer), &result));
    return result;
}

template <typename D> bool consume_RealtimeStreaming_Network_IDataBundle<D>::RemoveBuffer(RealtimeStreaming::Network::DataBuffer const& dataBuffer) const
{
    bool result{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundle)->RemoveBuffer(get_abi(dataBuffer), &result));
    return result;
}

template <typename D> void consume_RealtimeStreaming_Network_IDataBundle<D>::Reset() const
{
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundle)->Reset());
}

template <typename D> RealtimeStreaming::Common::PayloadType consume_RealtimeStreaming_Network_IDataBundleArgs<D>::PayloadType() const
{
    RealtimeStreaming::Common::PayloadType value{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundleArgs)->get_PayloadType(put_abi(value)));
    return value;
}

template <typename D> RealtimeStreaming::Network::Connection consume_RealtimeStreaming_Network_IDataBundleArgs<D>::DataConnection() const
{
    RealtimeStreaming::Network::Connection value{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundleArgs)->get_DataConnection(put_abi(value)));
    return value;
}

template <typename D> RealtimeStreaming::Network::DataBundle consume_RealtimeStreaming_Network_IDataBundleArgs<D>::Bundle() const
{
    RealtimeStreaming::Network::DataBundle value{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundleArgs)->get_Bundle(put_abi(value)));
    return value;
}

template <typename D> RealtimeStreaming::Network::DataBundleArgs consume_RealtimeStreaming_Network_IDataBundleArgsFactory<D>::CreateInstance(RealtimeStreaming::Common::PayloadType const& type, RealtimeStreaming::Network::Connection const& connection, RealtimeStreaming::Network::DataBundle const& dataBundle) const
{
    RealtimeStreaming::Network::DataBundleArgs value{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IDataBundleArgsFactory)->CreateInstance(get_abi(type), get_abi(connection), get_abi(dataBundle), put_abi(value)));
    return value;
}

template <typename D> Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> consume_RealtimeStreaming_Network_IListener<D>::ListenAsync() const
{
    Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> operation{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IListener)->ListenAsync(put_abi(operation)));
    return operation;
}

template <typename D> winrt::event_token consume_RealtimeStreaming_Network_IListener<D>::Closed(Windows::Foundation::EventHandler<bool> const& handler) const
{
    winrt::event_token token{};
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IListener)->add_Closed(get_abi(handler), put_abi(token)));
    return token;
}

template <typename D> typename consume_RealtimeStreaming_Network_IListener<D>::Closed_revoker consume_RealtimeStreaming_Network_IListener<D>::Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const
{
    return impl::make_event_revoker<D, Closed_revoker>(this, Closed(handler));
}

template <typename D> void consume_RealtimeStreaming_Network_IListener<D>::Closed(winrt::event_token const& token) const noexcept
{
    WINRT_VERIFY_(0, WINRT_SHIM(RealtimeStreaming::Network::IListener)->remove_Closed(get_abi(token)));
}

template <typename D> RealtimeStreaming::Network::Listener consume_RealtimeStreaming_Network_IListenerFactory<D>::CreateInstance(uint16_t port) const
{
    RealtimeStreaming::Network::Listener value{ nullptr };
    check_hresult(WINRT_SHIM(RealtimeStreaming::Network::IListenerFactory)->CreateInstance(port, put_abi(value)));
    return value;
}

template <> struct delegate<RealtimeStreaming::Network::DisconnectedDelegate>
{
    template <typename H>
    struct type : implements_delegate<RealtimeStreaming::Network::DisconnectedDelegate, H>
    {
        type(H&& handler) : implements_delegate<RealtimeStreaming::Network::DisconnectedDelegate, H>(std::forward<H>(handler)) {}

        int32_t WINRT_CALL Invoke() noexcept final
        {
            try
            {
                (*this)();
                return 0;
            }
            catch (...)
            {
                return to_hresult();
            }
        }
    };
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IConnection> : produce_base<D, RealtimeStreaming::Network::IConnection>
{
    int32_t WINRT_CALL SendPayloadTypeAsync(RealtimeStreaming::Common::PayloadType type, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SendPayloadTypeAsync, WINRT_WRAP(Windows::Foundation::IAsyncAction), RealtimeStreaming::Common::PayloadType const);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().SendPayloadTypeAsync(*reinterpret_cast<RealtimeStreaming::Common::PayloadType const*>(&type)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL SendBundleAsync(void* dataBundle, void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(SendBundleAsync, WINRT_WRAP(Windows::Foundation::IAsyncAction), RealtimeStreaming::Network::DataBundle const);
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().SendBundleAsync(*reinterpret_cast<RealtimeStreaming::Network::DataBundle const*>(&dataBundle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_IsConnected(bool* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(IsConnected, WINRT_WRAP(bool));
            *value = detach_from<bool>(this->shim().IsConnected());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_ConnectionInfo(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ConnectionInfo, WINRT_WRAP(Windows::Networking::Sockets::StreamSocketInformation));
            *value = detach_from<Windows::Networking::Sockets::StreamSocketInformation>(this->shim().ConnectionInfo());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL add_Disconnected(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Disconnected, WINRT_WRAP(winrt::event_token), RealtimeStreaming::Network::DisconnectedDelegate const&);
            *token = detach_from<winrt::event_token>(this->shim().Disconnected(*reinterpret_cast<RealtimeStreaming::Network::DisconnectedDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_Disconnected(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(Disconnected, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().Disconnected(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }

    int32_t WINRT_CALL add_Received(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Received, WINRT_WRAP(winrt::event_token), Windows::Foundation::EventHandler<RealtimeStreaming::Network::DataBundleArgs> const&);
            *token = detach_from<winrt::event_token>(this->shim().Received(*reinterpret_cast<Windows::Foundation::EventHandler<RealtimeStreaming::Network::DataBundleArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_Received(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(Received, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().Received(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IConnectionFactory> : produce_base<D, RealtimeStreaming::Network::IConnectionFactory>
{
    int32_t WINRT_CALL CreateInstance(void* streamSocket, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(RealtimeStreaming::Network::Connection), Windows::Networking::Sockets::StreamSocket const&);
            *value = detach_from<RealtimeStreaming::Network::Connection>(this->shim().CreateInstance(*reinterpret_cast<Windows::Networking::Sockets::StreamSocket const*>(&streamSocket)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IConnector> : produce_base<D, RealtimeStreaming::Network::IConnector>
{
    int32_t WINRT_CALL ConnectAsync(void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ConnectAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection>));
            *operation = detach_from<Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection>>(this->shim().ConnectAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL add_Closed(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Closed, WINRT_WRAP(winrt::event_token), Windows::Foundation::EventHandler<bool> const&);
            *token = detach_from<winrt::event_token>(this->shim().Closed(*reinterpret_cast<Windows::Foundation::EventHandler<bool> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_Closed(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(Closed, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().Closed(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IDataBuffer> : produce_base<D, RealtimeStreaming::Network::IDataBuffer>
{
    int32_t WINRT_CALL get_CurrentLength(uint64_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CurrentLength, WINRT_WRAP(uint64_t));
            *value = detach_from<uint64_t>(this->shim().CurrentLength());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_CurrentLength(uint64_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CurrentLength, WINRT_WRAP(void), uint64_t);
            this->shim().CurrentLength(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Offset(uint64_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Offset, WINRT_WRAP(uint64_t));
            *value = detach_from<uint64_t>(this->shim().Offset());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL put_Offset(uint64_t value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Offset, WINRT_WRAP(void), uint64_t);
            this->shim().Offset(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL TrimLeft(uint64_t cbSize) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(TrimLeft, WINRT_WRAP(void), uint64_t);
            this->shim().TrimLeft(cbSize);
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL TrimRight(uint64_t cbSize, void** result) noexcept final
    {
        try
        {
            *result = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(TrimRight, WINRT_WRAP(RealtimeStreaming::Network::DataBuffer), uint64_t);
            *result = detach_from<RealtimeStreaming::Network::DataBuffer>(this->shim().TrimRight(cbSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Reset() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Reset, WINRT_WRAP(void));
            this->shim().Reset();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IDataBufferFactory> : produce_base<D, RealtimeStreaming::Network::IDataBufferFactory>
{
    int32_t WINRT_CALL CreateInstance(uint64_t size, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(RealtimeStreaming::Network::DataBuffer), uint64_t);
            *value = detach_from<RealtimeStreaming::Network::DataBuffer>(this->shim().CreateInstance(size));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IDataBundle> : produce_base<D, RealtimeStreaming::Network::IDataBundle>
{
    int32_t WINRT_CALL get_BufferCount(uint32_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(BufferCount, WINRT_WRAP(uint32_t));
            *value = detach_from<uint32_t>(this->shim().BufferCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_TotalSize(uint64_t* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(TotalSize, WINRT_WRAP(uint64_t));
            *value = detach_from<uint64_t>(this->shim().TotalSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL AddBuffer(void* dataBuffer) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(AddBuffer, WINRT_WRAP(void), RealtimeStreaming::Network::DataBuffer const&);
            this->shim().AddBuffer(*reinterpret_cast<RealtimeStreaming::Network::DataBuffer const*>(&dataBuffer));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL InsertBuffer(uint32_t index, void* dataBuffer, bool* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(InsertBuffer, WINRT_WRAP(bool), uint32_t, RealtimeStreaming::Network::DataBuffer const&);
            *result = detach_from<bool>(this->shim().InsertBuffer(index, *reinterpret_cast<RealtimeStreaming::Network::DataBuffer const*>(&dataBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL RemoveBuffer(void* dataBuffer, bool* result) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(RemoveBuffer, WINRT_WRAP(bool), RealtimeStreaming::Network::DataBuffer const&);
            *result = detach_from<bool>(this->shim().RemoveBuffer(*reinterpret_cast<RealtimeStreaming::Network::DataBuffer const*>(&dataBuffer)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL Reset() noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Reset, WINRT_WRAP(void));
            this->shim().Reset();
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IDataBundleArgs> : produce_base<D, RealtimeStreaming::Network::IDataBundleArgs>
{
    int32_t WINRT_CALL get_PayloadType(RealtimeStreaming::Common::PayloadType* value) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(PayloadType, WINRT_WRAP(RealtimeStreaming::Common::PayloadType));
            *value = detach_from<RealtimeStreaming::Common::PayloadType>(this->shim().PayloadType());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_DataConnection(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(DataConnection, WINRT_WRAP(RealtimeStreaming::Network::Connection));
            *value = detach_from<RealtimeStreaming::Network::Connection>(this->shim().DataConnection());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL get_Bundle(void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Bundle, WINRT_WRAP(RealtimeStreaming::Network::DataBundle));
            *value = detach_from<RealtimeStreaming::Network::DataBundle>(this->shim().Bundle());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IDataBundleArgsFactory> : produce_base<D, RealtimeStreaming::Network::IDataBundleArgsFactory>
{
    int32_t WINRT_CALL CreateInstance(RealtimeStreaming::Common::PayloadType type, void* connection, void* dataBundle, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(RealtimeStreaming::Network::DataBundleArgs), RealtimeStreaming::Common::PayloadType const&, RealtimeStreaming::Network::Connection const&, RealtimeStreaming::Network::DataBundle const&);
            *value = detach_from<RealtimeStreaming::Network::DataBundleArgs>(this->shim().CreateInstance(*reinterpret_cast<RealtimeStreaming::Common::PayloadType const*>(&type), *reinterpret_cast<RealtimeStreaming::Network::Connection const*>(&connection), *reinterpret_cast<RealtimeStreaming::Network::DataBundle const*>(&dataBundle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IDataBundleFactory> : produce_base<D, RealtimeStreaming::Network::IDataBundleFactory>
{};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IListener> : produce_base<D, RealtimeStreaming::Network::IListener>
{
    int32_t WINRT_CALL ListenAsync(void** operation) noexcept final
    {
        try
        {
            *operation = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(ListenAsync, WINRT_WRAP(Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection>));
            *operation = detach_from<Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection>>(this->shim().ListenAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL add_Closed(void* handler, winrt::event_token* token) noexcept final
    {
        try
        {
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(Closed, WINRT_WRAP(winrt::event_token), Windows::Foundation::EventHandler<bool> const&);
            *token = detach_from<winrt::event_token>(this->shim().Closed(*reinterpret_cast<Windows::Foundation::EventHandler<bool> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }

    int32_t WINRT_CALL remove_Closed(winrt::event_token token) noexcept final
    {
        typename D::abi_guard guard(this->shim());
        WINRT_ASSERT_DECLARATION(Closed, WINRT_WRAP(void), winrt::event_token const&);
        this->shim().Closed(*reinterpret_cast<winrt::event_token const*>(&token));
        return 0;
    }
};

template <typename D>
struct produce<D, RealtimeStreaming::Network::IListenerFactory> : produce_base<D, RealtimeStreaming::Network::IListenerFactory>
{
    int32_t WINRT_CALL CreateInstance(uint16_t port, void** value) noexcept final
    {
        try
        {
            *value = nullptr;
            typename D::abi_guard guard(this->shim());
            WINRT_ASSERT_DECLARATION(CreateInstance, WINRT_WRAP(RealtimeStreaming::Network::Listener), uint16_t);
            *value = detach_from<RealtimeStreaming::Network::Listener>(this->shim().CreateInstance(port));
            return 0;
        }
        catch (...) { return to_hresult(); }
    }
};

}

WINRT_EXPORT namespace winrt::RealtimeStreaming::Network {

inline Connection::Connection() :
    Connection(impl::call_factory<Connection>([](auto&& f) { return f.template ActivateInstance<Connection>(); }))
{}

inline Connection::Connection(Windows::Networking::Sockets::StreamSocket const& streamSocket) :
    Connection(impl::call_factory<Connection, RealtimeStreaming::Network::IConnectionFactory>([&](auto&& f) { return f.CreateInstance(streamSocket); }))
{}

inline DataBuffer::DataBuffer() :
    DataBuffer(impl::call_factory<DataBuffer>([](auto&& f) { return f.template ActivateInstance<DataBuffer>(); }))
{}

inline DataBuffer::DataBuffer(uint64_t size) :
    DataBuffer(impl::call_factory<DataBuffer, RealtimeStreaming::Network::IDataBufferFactory>([&](auto&& f) { return f.CreateInstance(size); }))
{}

inline DataBundleArgs::DataBundleArgs(RealtimeStreaming::Common::PayloadType const& type, RealtimeStreaming::Network::Connection const& connection, RealtimeStreaming::Network::DataBundle const& dataBundle) :
    DataBundleArgs(impl::call_factory<DataBundleArgs, RealtimeStreaming::Network::IDataBundleArgsFactory>([&](auto&& f) { return f.CreateInstance(type, connection, dataBundle); }))
{}

inline Listener::Listener(uint16_t port) :
    Listener(impl::call_factory<Listener, RealtimeStreaming::Network::IListenerFactory>([&](auto&& f) { return f.CreateInstance(port); }))
{}

template <typename L> DisconnectedDelegate::DisconnectedDelegate(L handler) :
    DisconnectedDelegate(impl::make_delegate<DisconnectedDelegate>(std::forward<L>(handler)))
{}

template <typename F> DisconnectedDelegate::DisconnectedDelegate(F* handler) :
    DisconnectedDelegate([=](auto&&... args) { return handler(args...); })
{}

template <typename O, typename M> DisconnectedDelegate::DisconnectedDelegate(O* object, M method) :
    DisconnectedDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
{}

template <typename O, typename M> DisconnectedDelegate::DisconnectedDelegate(com_ptr<O>&& object, M method) :
    DisconnectedDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
{}

template <typename O, typename M> DisconnectedDelegate::DisconnectedDelegate(weak_ref<O>&& object, M method) :
    DisconnectedDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
{}

inline void DisconnectedDelegate::operator()() const
{
    check_hresult((*(impl::abi_t<DisconnectedDelegate>**)this)->Invoke());
}

}

namespace winrt::impl {

struct property_RealtimeStreaming_Network_IConnection
{ struct named {
    struct ConnectionInfo
    {
        struct name { static constexpr std::wstring_view value{ L"ConnectionInfo"sv }; };
        using property_type = winrt::Windows::Networking::Sockets::StreamSocketInformation;
        using target_type = winrt::RealtimeStreaming::Network::IConnection;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ConnectionInfo();
            }
        };
    };
    struct IsConnected
    {
        struct name { static constexpr std::wstring_view value{ L"IsConnected"sv }; };
        using property_type = bool;
        using target_type = winrt::RealtimeStreaming::Network::IConnection;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.IsConnected();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ConnectionInfo, named::IsConnected>; };
};

struct property_RealtimeStreaming_Network_IDataBuffer
{ struct named {
    struct CurrentLength
    {
        struct name { static constexpr std::wstring_view value{ L"CurrentLength"sv }; };
        using property_type = uint64_t;
        using target_type = winrt::RealtimeStreaming::Network::IDataBuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.CurrentLength();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.CurrentLength(std::forward<Value>(value));
            }
        };
    };
    struct Offset
    {
        struct name { static constexpr std::wstring_view value{ L"Offset"sv }; };
        using property_type = uint64_t;
        using target_type = winrt::RealtimeStreaming::Network::IDataBuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Offset();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Offset(std::forward<Value>(value));
            }
        };
    };};
    struct list { using type = impl::typelist<named::CurrentLength, named::Offset>; };
};

struct property_RealtimeStreaming_Network_IDataBundle
{ struct named {
    struct BufferCount
    {
        struct name { static constexpr std::wstring_view value{ L"BufferCount"sv }; };
        using property_type = uint32_t;
        using target_type = winrt::RealtimeStreaming::Network::IDataBundle;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.BufferCount();
            }
        };
    };
    struct TotalSize
    {
        struct name { static constexpr std::wstring_view value{ L"TotalSize"sv }; };
        using property_type = uint64_t;
        using target_type = winrt::RealtimeStreaming::Network::IDataBundle;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.TotalSize();
            }
        };
    };};
    struct list { using type = impl::typelist<named::BufferCount, named::TotalSize>; };
};

struct property_RealtimeStreaming_Network_IDataBundleArgs
{ struct named {
    struct Bundle
    {
        struct name { static constexpr std::wstring_view value{ L"Bundle"sv }; };
        using property_type = winrt::RealtimeStreaming::Network::DataBundle;
        using target_type = winrt::RealtimeStreaming::Network::IDataBundleArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Bundle();
            }
        };
    };
    struct DataConnection
    {
        struct name { static constexpr std::wstring_view value{ L"DataConnection"sv }; };
        using property_type = winrt::RealtimeStreaming::Network::Connection;
        using target_type = winrt::RealtimeStreaming::Network::IDataBundleArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.DataConnection();
            }
        };
    };
    struct PayloadType
    {
        struct name { static constexpr std::wstring_view value{ L"PayloadType"sv }; };
        using property_type = winrt::RealtimeStreaming::Common::PayloadType;
        using target_type = winrt::RealtimeStreaming::Network::IDataBundleArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.PayloadType();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Bundle, named::DataConnection, named::PayloadType>; };
};

struct property_RealtimeStreaming_Network_Connection
{ struct named {
    struct ConnectionInfo
    {
        struct name { static constexpr std::wstring_view value{ L"ConnectionInfo"sv }; };
        using property_type = winrt::Windows::Networking::Sockets::StreamSocketInformation;
        using target_type = winrt::RealtimeStreaming::Network::Connection;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.ConnectionInfo();
            }
        };
    };
    struct IsConnected
    {
        struct name { static constexpr std::wstring_view value{ L"IsConnected"sv }; };
        using property_type = bool;
        using target_type = winrt::RealtimeStreaming::Network::Connection;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.IsConnected();
            }
        };
    };};
    struct list { using type = impl::typelist<named::ConnectionInfo, named::IsConnected>; };
};

struct property_RealtimeStreaming_Network_DataBuffer
{ struct named {
    struct Offset
    {
        struct name { static constexpr std::wstring_view value{ L"Offset"sv }; };
        using property_type = uint64_t;
        using target_type = winrt::RealtimeStreaming::Network::DataBuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Offset();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Offset(std::forward<Value>(value));
            }
        };
    };
    struct CurrentLength
    {
        struct name { static constexpr std::wstring_view value{ L"CurrentLength"sv }; };
        using property_type = uint64_t;
        using target_type = winrt::RealtimeStreaming::Network::DataBuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.CurrentLength();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.CurrentLength(std::forward<Value>(value));
            }
        };
    };
    struct Length
    {
        struct name { static constexpr std::wstring_view value{ L"Length"sv }; };
        using property_type = uint32_t;
        using target_type = winrt::RealtimeStreaming::Network::DataBuffer;

        using is_readable = std::true_type;
        using is_writable = std::true_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Length();
            }
        };
        struct setter
        {
            template <typename Value>
            void operator()(target_type const& target, Value&& value) const
            {
                target.Length(std::forward<Value>(value));
            }
        };
    };
    struct Capacity
    {
        struct name { static constexpr std::wstring_view value{ L"Capacity"sv }; };
        using property_type = uint32_t;
        using target_type = winrt::RealtimeStreaming::Network::DataBuffer;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Capacity();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Offset, named::CurrentLength, named::Length, named::Capacity>; };
};

struct property_RealtimeStreaming_Network_DataBundle
{ struct named {
    struct BufferCount
    {
        struct name { static constexpr std::wstring_view value{ L"BufferCount"sv }; };
        using property_type = uint32_t;
        using target_type = winrt::RealtimeStreaming::Network::DataBundle;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.BufferCount();
            }
        };
    };
    struct TotalSize
    {
        struct name { static constexpr std::wstring_view value{ L"TotalSize"sv }; };
        using property_type = uint64_t;
        using target_type = winrt::RealtimeStreaming::Network::DataBundle;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.TotalSize();
            }
        };
    };};
    struct list { using type = impl::typelist<named::BufferCount, named::TotalSize>; };
};

struct property_RealtimeStreaming_Network_DataBundleArgs
{ struct named {
    struct Bundle
    {
        struct name { static constexpr std::wstring_view value{ L"Bundle"sv }; };
        using property_type = winrt::RealtimeStreaming::Network::DataBundle;
        using target_type = winrt::RealtimeStreaming::Network::DataBundleArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.Bundle();
            }
        };
    };
    struct DataConnection
    {
        struct name { static constexpr std::wstring_view value{ L"DataConnection"sv }; };
        using property_type = winrt::RealtimeStreaming::Network::Connection;
        using target_type = winrt::RealtimeStreaming::Network::DataBundleArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.DataConnection();
            }
        };
    };
    struct PayloadType
    {
        struct name { static constexpr std::wstring_view value{ L"PayloadType"sv }; };
        using property_type = winrt::RealtimeStreaming::Common::PayloadType;
        using target_type = winrt::RealtimeStreaming::Network::DataBundleArgs;

        using is_readable = std::true_type;
        using is_writable = std::false_type;
        using is_static = std::false_type;
        struct getter
        {
            auto operator()(target_type const& target) const
            {
                return target.PayloadType();
            }
        };
    };};
    struct list { using type = impl::typelist<named::Bundle, named::DataConnection, named::PayloadType>; };
};

}

WINRT_EXPORT namespace winrt::experimental::reflect {
template <> struct named_property<RealtimeStreaming::Network::IConnection> : impl::property_RealtimeStreaming_Network_IConnection::named {};
template <> struct properties<RealtimeStreaming::Network::IConnection> : impl::property_RealtimeStreaming_Network_IConnection::list {};
template <> struct named_property<RealtimeStreaming::Network::IDataBuffer> : impl::property_RealtimeStreaming_Network_IDataBuffer::named {};
template <> struct properties<RealtimeStreaming::Network::IDataBuffer> : impl::property_RealtimeStreaming_Network_IDataBuffer::list {};
template <> struct named_property<RealtimeStreaming::Network::IDataBundle> : impl::property_RealtimeStreaming_Network_IDataBundle::named {};
template <> struct properties<RealtimeStreaming::Network::IDataBundle> : impl::property_RealtimeStreaming_Network_IDataBundle::list {};
template <> struct named_property<RealtimeStreaming::Network::IDataBundleArgs> : impl::property_RealtimeStreaming_Network_IDataBundleArgs::named {};
template <> struct properties<RealtimeStreaming::Network::IDataBundleArgs> : impl::property_RealtimeStreaming_Network_IDataBundleArgs::list {};
template <> struct named_property<RealtimeStreaming::Network::Connection> : impl::property_RealtimeStreaming_Network_Connection::named {};
template <> struct properties<RealtimeStreaming::Network::Connection> : impl::property_RealtimeStreaming_Network_Connection::list {};
template <> struct named_property<RealtimeStreaming::Network::DataBuffer> : impl::property_RealtimeStreaming_Network_DataBuffer::named {};
template <> struct properties<RealtimeStreaming::Network::DataBuffer> : impl::property_RealtimeStreaming_Network_DataBuffer::list {};
template <> struct named_property<RealtimeStreaming::Network::DataBundle> : impl::property_RealtimeStreaming_Network_DataBundle::named {};
template <> struct properties<RealtimeStreaming::Network::DataBundle> : impl::property_RealtimeStreaming_Network_DataBundle::list {};
template <> struct named_property<RealtimeStreaming::Network::DataBundleArgs> : impl::property_RealtimeStreaming_Network_DataBundleArgs::named {};
template <> struct properties<RealtimeStreaming::Network::DataBundleArgs> : impl::property_RealtimeStreaming_Network_DataBundleArgs::list {};

}

WINRT_EXPORT namespace std {

template<> struct hash<winrt::RealtimeStreaming::Network::IConnection> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IConnection> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IConnectionFactory> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IConnectionFactory> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IConnector> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IConnector> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IDataBuffer> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IDataBuffer> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IDataBufferFactory> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IDataBufferFactory> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IDataBundle> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IDataBundle> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IDataBundleArgs> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IDataBundleArgs> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IDataBundleArgsFactory> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IDataBundleArgsFactory> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IDataBundleFactory> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IDataBundleFactory> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IListener> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IListener> {};
template<> struct hash<winrt::RealtimeStreaming::Network::IListenerFactory> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::IListenerFactory> {};
template<> struct hash<winrt::RealtimeStreaming::Network::Connection> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::Connection> {};
template<> struct hash<winrt::RealtimeStreaming::Network::Connector> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::Connector> {};
template<> struct hash<winrt::RealtimeStreaming::Network::DataBuffer> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::DataBuffer> {};
template<> struct hash<winrt::RealtimeStreaming::Network::DataBundle> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::DataBundle> {};
template<> struct hash<winrt::RealtimeStreaming::Network::DataBundleArgs> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::DataBundleArgs> {};
template<> struct hash<winrt::RealtimeStreaming::Network::Listener> : winrt::impl::hash_base<winrt::RealtimeStreaming::Network::Listener> {};

}
