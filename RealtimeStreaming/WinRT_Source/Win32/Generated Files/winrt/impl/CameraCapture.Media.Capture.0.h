// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180227.3

#pragma once

WINRT_EXPORT namespace winrt::Windows::Foundation::Collections {

struct IPropertySet;

}

WINRT_EXPORT namespace winrt::Windows::Media::Capture {

enum class MediaStreamType;

}

WINRT_EXPORT namespace winrt::Windows::Media::MediaProperties {

struct AudioEncodingProperties;
struct IMediaEncodingProperties;
struct MediaEncodingProfile;
struct VideoEncodingProperties;

}

WINRT_EXPORT namespace winrt::CameraCapture::Media::Capture {

enum class AudioMixerMode : int32_t
{
    Mic = 0,
    Loopback = 1,
    MicAndLoopback = 2,
};

enum class State : int32_t
{
    Ready = 0,
    Started = 1,
    Paused = 2,
    Stopped = 3,
    Eos = 4,
    Shutdown = 5,
};

struct IAudioPayload;
struct IMrcAudioEffect;
struct IMrcVideoEffect;
struct IPayload;
struct IPayloadFactory;
struct IPayloadHandler;
struct ISink;
struct ISinkFactory;
struct IStreamSink;
struct IStreamSinkFactory;
struct IVideoPayload;
struct AudioPayload;
struct MrcAudioEffect;
struct MrcVideoEffect;
struct Payload;
struct PayloadHandler;
struct Sink;
struct StreamSink;
struct VideoPayload;

}

namespace winrt::impl {

template <> struct category<CameraCapture::Media::Capture::IAudioPayload>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IMrcAudioEffect>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IMrcVideoEffect>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IPayload>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IPayloadFactory>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IPayloadHandler>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::ISink>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::ISinkFactory>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IStreamSink>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IStreamSinkFactory>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::IVideoPayload>{ using type = interface_category; };
template <> struct category<CameraCapture::Media::Capture::AudioPayload>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::MrcAudioEffect>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::MrcVideoEffect>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::Payload>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::PayloadHandler>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::Sink>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::StreamSink>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::VideoPayload>{ using type = class_category; };
template <> struct category<CameraCapture::Media::Capture::AudioMixerMode>{ using type = enum_category; };
template <> struct category<CameraCapture::Media::Capture::State>{ using type = enum_category; };
template <> struct name<CameraCapture::Media::Capture::IAudioPayload>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IAudioPayload" }; };
template <> struct name<CameraCapture::Media::Capture::IMrcAudioEffect>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IMrcAudioEffect" }; };
template <> struct name<CameraCapture::Media::Capture::IMrcVideoEffect>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IMrcVideoEffect" }; };
template <> struct name<CameraCapture::Media::Capture::IPayload>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IPayload" }; };
template <> struct name<CameraCapture::Media::Capture::IPayloadFactory>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IPayloadFactory" }; };
template <> struct name<CameraCapture::Media::Capture::IPayloadHandler>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IPayloadHandler" }; };
template <> struct name<CameraCapture::Media::Capture::ISink>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.ISink" }; };
template <> struct name<CameraCapture::Media::Capture::ISinkFactory>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.ISinkFactory" }; };
template <> struct name<CameraCapture::Media::Capture::IStreamSink>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IStreamSink" }; };
template <> struct name<CameraCapture::Media::Capture::IStreamSinkFactory>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IStreamSinkFactory" }; };
template <> struct name<CameraCapture::Media::Capture::IVideoPayload>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.IVideoPayload" }; };
template <> struct name<CameraCapture::Media::Capture::AudioPayload>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.AudioPayload" }; };
template <> struct name<CameraCapture::Media::Capture::MrcAudioEffect>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.MrcAudioEffect" }; };
template <> struct name<CameraCapture::Media::Capture::MrcVideoEffect>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.MrcVideoEffect" }; };
template <> struct name<CameraCapture::Media::Capture::Payload>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.Payload" }; };
template <> struct name<CameraCapture::Media::Capture::PayloadHandler>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.PayloadHandler" }; };
template <> struct name<CameraCapture::Media::Capture::Sink>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.Sink" }; };
template <> struct name<CameraCapture::Media::Capture::StreamSink>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.StreamSink" }; };
template <> struct name<CameraCapture::Media::Capture::VideoPayload>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.VideoPayload" }; };
template <> struct name<CameraCapture::Media::Capture::AudioMixerMode>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.AudioMixerMode" }; };
template <> struct name<CameraCapture::Media::Capture::State>{ static constexpr auto & value{ L"CameraCapture.Media.Capture.State" }; };
template <> struct guid<CameraCapture::Media::Capture::IAudioPayload>{ static constexpr GUID value{ 0x08A98EE1,0x23D1,0x50B0,{ 0xAD,0xB3,0xAC,0x61,0xF7,0xFE,0x66,0x80 } }; };
template <> struct guid<CameraCapture::Media::Capture::IMrcAudioEffect>{ static constexpr GUID value{ 0x76221BA9,0xD6B8,0x51F9,{ 0xA7,0xB4,0x20,0x39,0x51,0x72,0xB3,0x89 } }; };
template <> struct guid<CameraCapture::Media::Capture::IMrcVideoEffect>{ static constexpr GUID value{ 0x8B42FA15,0x7798,0x57B4,{ 0x92,0x71,0xFF,0xFF,0xF9,0x0C,0x3F,0x54 } }; };
template <> struct guid<CameraCapture::Media::Capture::IPayload>{ static constexpr GUID value{ 0x90486F88,0x21FC,0x4A36,{ 0x9B,0x97,0xA4,0x45,0xF8,0xDE,0x7A,0x35 } }; };
template <> struct guid<CameraCapture::Media::Capture::IPayloadFactory>{ static constexpr GUID value{ 0xE9DE5B47,0xF006,0x4026,{ 0x96,0x88,0xE3,0x0F,0x9E,0xF9,0xF5,0x2C } }; };
template <> struct guid<CameraCapture::Media::Capture::IPayloadHandler>{ static constexpr GUID value{ 0x10B74197,0xDED1,0x5F1D,{ 0x9B,0x22,0xDF,0xE6,0xEB,0xF6,0x94,0x56 } }; };
template <> struct guid<CameraCapture::Media::Capture::ISink>{ static constexpr GUID value{ 0x46D075B8,0x4A40,0x5FC0,{ 0xAA,0x6B,0xD2,0x94,0x6B,0xAC,0x8F,0x4A } }; };
template <> struct guid<CameraCapture::Media::Capture::ISinkFactory>{ static constexpr GUID value{ 0x32083101,0xFB59,0x5E2B,{ 0xB8,0xBD,0xE7,0x4B,0xE3,0x0D,0x46,0xC2 } }; };
template <> struct guid<CameraCapture::Media::Capture::IStreamSink>{ static constexpr GUID value{ 0x1417583E,0x03DF,0x5BE8,{ 0x83,0xA9,0x27,0x90,0x99,0x71,0x93,0x2B } }; };
template <> struct guid<CameraCapture::Media::Capture::IStreamSinkFactory>{ static constexpr GUID value{ 0x4E06C7B3,0xFA51,0x5D93,{ 0x97,0x2B,0x4A,0x6B,0xDC,0x75,0x3F,0x1A } }; };
template <> struct guid<CameraCapture::Media::Capture::IVideoPayload>{ static constexpr GUID value{ 0x0764204F,0xBF72,0x5889,{ 0xB0,0x65,0xAC,0x45,0x19,0x31,0x16,0x49 } }; };
template <> struct default_interface<CameraCapture::Media::Capture::AudioPayload>{ using type = CameraCapture::Media::Capture::IAudioPayload; };
template <> struct default_interface<CameraCapture::Media::Capture::MrcAudioEffect>{ using type = CameraCapture::Media::Capture::IMrcAudioEffect; };
template <> struct default_interface<CameraCapture::Media::Capture::MrcVideoEffect>{ using type = CameraCapture::Media::Capture::IMrcVideoEffect; };
template <> struct default_interface<CameraCapture::Media::Capture::Payload>{ using type = CameraCapture::Media::Capture::IPayload; };
template <> struct default_interface<CameraCapture::Media::Capture::PayloadHandler>{ using type = CameraCapture::Media::Capture::IPayloadHandler; };
template <> struct default_interface<CameraCapture::Media::Capture::Sink>{ using type = CameraCapture::Media::Capture::ISink; };
template <> struct default_interface<CameraCapture::Media::Capture::StreamSink>{ using type = CameraCapture::Media::Capture::IStreamSink; };
template <> struct default_interface<CameraCapture::Media::Capture::VideoPayload>{ using type = CameraCapture::Media::Capture::IVideoPayload; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IAudioPayload
{
    Windows::Media::MediaProperties::AudioEncodingProperties AudioProperties() const;
};
template <> struct consume<CameraCapture::Media::Capture::IAudioPayload> { template <typename D> using type = consume_CameraCapture_Media_Capture_IAudioPayload<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IMrcAudioEffect
{
    CameraCapture::Media::Capture::AudioMixerMode MixerMode() const;
    void MixerMode(CameraCapture::Media::Capture::AudioMixerMode const& value) const;
};
template <> struct consume<CameraCapture::Media::Capture::IMrcAudioEffect> { template <typename D> using type = consume_CameraCapture_Media_Capture_IMrcAudioEffect<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IMrcVideoEffect
{
    float GlobalOpacityCoefficient() const;
    void GlobalOpacityCoefficient(float value) const;
    bool HologramCompositionEnabled() const;
    void HologramCompositionEnabled(bool value) const;
    bool RecordingIndicatorEnabled() const;
    void RecordingIndicatorEnabled(bool value) const;
    Windows::Media::Capture::MediaStreamType StreamType() const;
    void StreamType(Windows::Media::Capture::MediaStreamType const& value) const;
    bool VideoStabilizationEnabled() const;
    void VideoStabilizationEnabled(bool value) const;
    uint32_t VideoStabilizationBufferLength() const;
    void VideoStabilizationBufferLength(uint32_t value) const;
    uint32_t VideoStabilizationMaximumBufferLength() const;
};
template <> struct consume<CameraCapture::Media::Capture::IMrcVideoEffect> { template <typename D> using type = consume_CameraCapture_Media_Capture_IMrcVideoEffect<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IPayload
{
    Windows::Media::MediaProperties::IMediaEncodingProperties MediaEncodingProperties() const;
};
template <> struct consume<CameraCapture::Media::Capture::IPayload> { template <typename D> using type = consume_CameraCapture_Media_Capture_IPayload<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IPayloadFactory
{
};
template <> struct consume<CameraCapture::Media::Capture::IPayloadFactory> { template <typename D> using type = consume_CameraCapture_Media_Capture_IPayloadFactory<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IPayloadHandler
{
    HRESULT QueuePayload(CameraCapture::Media::Capture::Payload const& payload) const;
    event_token OnSample(Windows::Foundation::EventHandler<CameraCapture::Media::Capture::Payload> const& handler) const;
    using OnSample_revoker = event_revoker<CameraCapture::Media::Capture::IPayloadHandler>;
    OnSample_revoker OnSample(auto_revoke_t, Windows::Foundation::EventHandler<CameraCapture::Media::Capture::Payload> const& handler) const;
    void OnSample(event_token const& token) const;
};
template <> struct consume<CameraCapture::Media::Capture::IPayloadHandler> { template <typename D> using type = consume_CameraCapture_Media_Capture_IPayloadHandler<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_ISink
{
    HRESULT OnEndOfStream() const;
    CameraCapture::Media::Capture::State State() const;
    CameraCapture::Media::Capture::PayloadHandler PayloadHandler() const;
    void PayloadHandler(CameraCapture::Media::Capture::PayloadHandler const& value) const;
};
template <> struct consume<CameraCapture::Media::Capture::ISink> { template <typename D> using type = consume_CameraCapture_Media_Capture_ISink<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_ISinkFactory
{
    CameraCapture::Media::Capture::Sink CreateInstance(Windows::Media::MediaProperties::MediaEncodingProfile const& encodingProfile) const;
};
template <> struct consume<CameraCapture::Media::Capture::ISinkFactory> { template <typename D> using type = consume_CameraCapture_Media_Capture_ISinkFactory<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IStreamSink
{
    HRESULT Start(int64_t systemTime, int64_t clockStartOffset) const;
    HRESULT Stop() const;
    HRESULT Shutdown() const;
    CameraCapture::Media::Capture::State State() const;
    void State(CameraCapture::Media::Capture::State const& value) const;
};
template <> struct consume<CameraCapture::Media::Capture::IStreamSink> { template <typename D> using type = consume_CameraCapture_Media_Capture_IStreamSink<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IStreamSinkFactory
{
    CameraCapture::Media::Capture::StreamSink CreateInstance(uint8_t index, Windows::Media::MediaProperties::IMediaEncodingProperties const& encodingProperties, CameraCapture::Media::Capture::Sink const& parent) const;
};
template <> struct consume<CameraCapture::Media::Capture::IStreamSinkFactory> { template <typename D> using type = consume_CameraCapture_Media_Capture_IStreamSinkFactory<D>; };

template <typename D>
struct consume_CameraCapture_Media_Capture_IVideoPayload
{
    Windows::Media::MediaProperties::VideoEncodingProperties VideoProperties() const;
};
template <> struct consume<CameraCapture::Media::Capture::IVideoPayload> { template <typename D> using type = consume_CameraCapture_Media_Capture_IVideoPayload<D>; };

template <> struct abi<CameraCapture::Media::Capture::IAudioPayload>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_AudioProperties(void** result) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::IMrcAudioEffect>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_MixerMode(CameraCapture::Media::Capture::AudioMixerMode* result) noexcept = 0;
    virtual HRESULT __stdcall put_MixerMode(CameraCapture::Media::Capture::AudioMixerMode value) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::IMrcVideoEffect>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_GlobalOpacityCoefficient(float* result) noexcept = 0;
    virtual HRESULT __stdcall put_GlobalOpacityCoefficient(float value) noexcept = 0;
    virtual HRESULT __stdcall get_HologramCompositionEnabled(bool* result) noexcept = 0;
    virtual HRESULT __stdcall put_HologramCompositionEnabled(bool value) noexcept = 0;
    virtual HRESULT __stdcall get_RecordingIndicatorEnabled(bool* result) noexcept = 0;
    virtual HRESULT __stdcall put_RecordingIndicatorEnabled(bool value) noexcept = 0;
    virtual HRESULT __stdcall get_StreamType(Windows::Media::Capture::MediaStreamType* result) noexcept = 0;
    virtual HRESULT __stdcall put_StreamType(Windows::Media::Capture::MediaStreamType value) noexcept = 0;
    virtual HRESULT __stdcall get_VideoStabilizationEnabled(bool* result) noexcept = 0;
    virtual HRESULT __stdcall put_VideoStabilizationEnabled(bool value) noexcept = 0;
    virtual HRESULT __stdcall get_VideoStabilizationBufferLength(uint32_t* result) noexcept = 0;
    virtual HRESULT __stdcall put_VideoStabilizationBufferLength(uint32_t value) noexcept = 0;
    virtual HRESULT __stdcall get_VideoStabilizationMaximumBufferLength(uint32_t* result) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::IPayload>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_MediaEncodingProperties(void** result) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::IPayloadFactory>{ struct type : IInspectable
{
};};

template <> struct abi<CameraCapture::Media::Capture::IPayloadHandler>{ struct type : IInspectable
{
    virtual HRESULT __stdcall QueuePayload(void* payload, HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall add_OnSample(void* handler, event_token* token) noexcept = 0;
    virtual HRESULT __stdcall remove_OnSample(event_token token) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::ISink>{ struct type : IInspectable
{
    virtual HRESULT __stdcall OnEndOfStream(HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall get_State(CameraCapture::Media::Capture::State* result) noexcept = 0;
    virtual HRESULT __stdcall get_PayloadHandler(void** result) noexcept = 0;
    virtual HRESULT __stdcall put_PayloadHandler(void* value) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::ISinkFactory>{ struct type : IInspectable
{
    virtual HRESULT __stdcall CreateInstance(void* encodingProfile, void** value) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::IStreamSink>{ struct type : IInspectable
{
    virtual HRESULT __stdcall Start(int64_t systemTime, int64_t clockStartOffset, HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall Stop(HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall Shutdown(HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall get_State(CameraCapture::Media::Capture::State* result) noexcept = 0;
    virtual HRESULT __stdcall put_State(CameraCapture::Media::Capture::State value) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::IStreamSinkFactory>{ struct type : IInspectable
{
    virtual HRESULT __stdcall CreateInstance(uint8_t index, void* encodingProperties, void* parent, void** value) noexcept = 0;
};};

template <> struct abi<CameraCapture::Media::Capture::IVideoPayload>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_VideoProperties(void** result) noexcept = 0;
};};

}
