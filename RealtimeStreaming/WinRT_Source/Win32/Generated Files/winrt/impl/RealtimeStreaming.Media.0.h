// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180821.2

#pragma once

WINRT_EXPORT namespace winrt::RealtimeStreaming::Network {

struct Connection;

}

WINRT_EXPORT namespace winrt::Windows::Foundation::Collections {

struct IPropertySet;

}

WINRT_EXPORT namespace winrt::Windows::Media::Core {

struct MediaStreamSource;

}

WINRT_EXPORT namespace winrt::Windows::Media::MediaProperties {

struct MediaEncodingProfile;
struct VideoEncodingProperties;

}

WINRT_EXPORT namespace winrt::RealtimeStreaming::Media {

enum class SinkStreamOperation : int32_t
{
    SetMediaType = 0,
    Start = 1,
    Restart = 2,
    Pause = 3,
    Stop = 4,
    ProcessSample = 5,
    PlaceMarker = 6,
    Count = 7,
};

enum class SinkStreamState : int32_t
{
    NotSet = 0,
    Ready = 1,
    Started = 2,
    Stopped = 3,
    Paused = 4,
    Count = 5,
};

enum class SourceStreamState : int32_t
{
    Invalid = 0,
    Opening = 1,
    Starting = 2,
    Started = 3,
    Stopped = 4,
    Shutdown = 5,
    Count = 6,
};

struct INetworkMediaSink;
struct INetworkMediaSinkFactory;
struct INetworkMediaSinkStream;
struct INetworkMediaSinkStreamFactory;
struct IRTSchemeHandler;
struct IRealtimeMediaPlayer;
struct IRealtimeMediaSource;
struct IRealtimeServer;
struct IRealtimeServerFactory;
struct NetworkMediaSink;
struct NetworkMediaSinkStream;
struct RTSchemeHandler;
struct RealtimeMediaPlayer;
struct RealtimeMediaSource;
struct RealtimeServer;

}

namespace winrt::impl {

template <> struct category<RealtimeStreaming::Media::INetworkMediaSink>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::INetworkMediaSinkFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::INetworkMediaSinkStream>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::INetworkMediaSinkStreamFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRTSchemeHandler>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRealtimeMediaPlayer>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRealtimeMediaSource>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRealtimeServer>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRealtimeServerFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::NetworkMediaSink>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::NetworkMediaSinkStream>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::RTSchemeHandler>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::RealtimeMediaPlayer>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::RealtimeMediaSource>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::RealtimeServer>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::SinkStreamOperation>{ using type = enum_category; };
template <> struct category<RealtimeStreaming::Media::SinkStreamState>{ using type = enum_category; };
template <> struct category<RealtimeStreaming::Media::SourceStreamState>{ using type = enum_category; };
template <> struct name<RealtimeStreaming::Media::INetworkMediaSink>{ static constexpr auto & value{ L"RealtimeStreaming.Media.INetworkMediaSink" }; };
template <> struct name<RealtimeStreaming::Media::INetworkMediaSinkFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Media.INetworkMediaSinkFactory" }; };
template <> struct name<RealtimeStreaming::Media::INetworkMediaSinkStream>{ static constexpr auto & value{ L"RealtimeStreaming.Media.INetworkMediaSinkStream" }; };
template <> struct name<RealtimeStreaming::Media::INetworkMediaSinkStreamFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Media.INetworkMediaSinkStreamFactory" }; };
template <> struct name<RealtimeStreaming::Media::IRTSchemeHandler>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRTSchemeHandler" }; };
template <> struct name<RealtimeStreaming::Media::IRealtimeMediaPlayer>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRealtimeMediaPlayer" }; };
template <> struct name<RealtimeStreaming::Media::IRealtimeMediaSource>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRealtimeMediaSource" }; };
template <> struct name<RealtimeStreaming::Media::IRealtimeServer>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRealtimeServer" }; };
template <> struct name<RealtimeStreaming::Media::IRealtimeServerFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRealtimeServerFactory" }; };
template <> struct name<RealtimeStreaming::Media::NetworkMediaSink>{ static constexpr auto & value{ L"RealtimeStreaming.Media.NetworkMediaSink" }; };
template <> struct name<RealtimeStreaming::Media::NetworkMediaSinkStream>{ static constexpr auto & value{ L"RealtimeStreaming.Media.NetworkMediaSinkStream" }; };
template <> struct name<RealtimeStreaming::Media::RTSchemeHandler>{ static constexpr auto & value{ L"RealtimeStreaming.Media.RTSchemeHandler" }; };
template <> struct name<RealtimeStreaming::Media::RealtimeMediaPlayer>{ static constexpr auto & value{ L"RealtimeStreaming.Media.RealtimeMediaPlayer" }; };
template <> struct name<RealtimeStreaming::Media::RealtimeMediaSource>{ static constexpr auto & value{ L"RealtimeStreaming.Media.RealtimeMediaSource" }; };
template <> struct name<RealtimeStreaming::Media::RealtimeServer>{ static constexpr auto & value{ L"RealtimeStreaming.Media.RealtimeServer" }; };
template <> struct name<RealtimeStreaming::Media::SinkStreamOperation>{ static constexpr auto & value{ L"RealtimeStreaming.Media.SinkStreamOperation" }; };
template <> struct name<RealtimeStreaming::Media::SinkStreamState>{ static constexpr auto & value{ L"RealtimeStreaming.Media.SinkStreamState" }; };
template <> struct name<RealtimeStreaming::Media::SourceStreamState>{ static constexpr auto & value{ L"RealtimeStreaming.Media.SourceStreamState" }; };
template <> struct guid_storage<RealtimeStreaming::Media::INetworkMediaSink>{ static constexpr guid value{ 0xAC3AB2F0,0x35DA,0x5E90,{ 0xB4,0xC2,0xA1,0x34,0x84,0xEB,0xEB,0xA2 } }; };
template <> struct guid_storage<RealtimeStreaming::Media::INetworkMediaSinkFactory>{ static constexpr guid value{ 0x5EA20D87,0x9952,0x5DD9,{ 0xB9,0xB5,0x5C,0xF1,0x98,0xCD,0x2A,0xA7 } }; };
template <> struct guid_storage<RealtimeStreaming::Media::INetworkMediaSinkStream>{ static constexpr guid value{ 0x98D2B666,0xDBD9,0x5DEF,{ 0x8C,0x8A,0x75,0x2C,0x47,0x68,0x3A,0x7A } }; };
template <> struct guid_storage<RealtimeStreaming::Media::INetworkMediaSinkStreamFactory>{ static constexpr guid value{ 0x6B4FADDC,0x5414,0x597E,{ 0xB7,0x32,0x6E,0x60,0x24,0x17,0xED,0x8D } }; };
template <> struct guid_storage<RealtimeStreaming::Media::IRTSchemeHandler>{ static constexpr guid value{ 0xA5596274,0xA51A,0x5F7A,{ 0x83,0xF6,0x55,0xCA,0x2D,0x33,0x4D,0x89 } }; };
template <> struct guid_storage<RealtimeStreaming::Media::IRealtimeMediaPlayer>{ static constexpr guid value{ 0x3D824337,0xCEBC,0x5785,{ 0xB0,0x54,0xAA,0x67,0x15,0xEA,0xAB,0x1C } }; };
template <> struct guid_storage<RealtimeStreaming::Media::IRealtimeMediaSource>{ static constexpr guid value{ 0x03F7C586,0x1504,0x5810,{ 0xAB,0x3A,0x7A,0x74,0xC9,0x9B,0x19,0x8D } }; };
template <> struct guid_storage<RealtimeStreaming::Media::IRealtimeServer>{ static constexpr guid value{ 0xBDF2A077,0x3916,0x5DE4,{ 0xB9,0xEA,0x74,0xF0,0x26,0xB0,0x59,0xD5 } }; };
template <> struct guid_storage<RealtimeStreaming::Media::IRealtimeServerFactory>{ static constexpr guid value{ 0x5346B092,0x8689,0x54DD,{ 0xAC,0x7A,0xED,0x45,0x75,0xCB,0x1B,0x98 } }; };
template <> struct default_interface<RealtimeStreaming::Media::NetworkMediaSink>{ using type = RealtimeStreaming::Media::INetworkMediaSink; };
template <> struct default_interface<RealtimeStreaming::Media::NetworkMediaSinkStream>{ using type = RealtimeStreaming::Media::INetworkMediaSinkStream; };
template <> struct default_interface<RealtimeStreaming::Media::RTSchemeHandler>{ using type = RealtimeStreaming::Media::IRTSchemeHandler; };
template <> struct default_interface<RealtimeStreaming::Media::RealtimeMediaPlayer>{ using type = RealtimeStreaming::Media::IRealtimeMediaPlayer; };
template <> struct default_interface<RealtimeStreaming::Media::RealtimeMediaSource>{ using type = RealtimeStreaming::Media::IRealtimeMediaSource; };
template <> struct default_interface<RealtimeStreaming::Media::RealtimeServer>{ using type = RealtimeStreaming::Media::IRealtimeServer; };

template <> struct abi<RealtimeStreaming::Media::INetworkMediaSink>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL add_Closed(void* handler, winrt::event_token* token) noexcept = 0;
    virtual int32_t WINRT_CALL remove_Closed(winrt::event_token token) noexcept = 0;
    virtual int32_t WINRT_CALL OnEndOfStream(uint32_t streamId, winrt::hresult* result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::INetworkMediaSinkFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(void* connection, void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::INetworkMediaSinkStream>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL Start(int64_t start, winrt::hresult* result) noexcept = 0;
    virtual int32_t WINRT_CALL Restart(winrt::hresult* result) noexcept = 0;
    virtual int32_t WINRT_CALL Stop(winrt::hresult* result) noexcept = 0;
    virtual int32_t WINRT_CALL Pause(winrt::hresult* result) noexcept = 0;
    virtual int32_t WINRT_CALL Shutdown(winrt::hresult* result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::INetworkMediaSinkStreamFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(uint32_t streamId, void* dataConnection, void* parentMediaSink, void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRTSchemeHandler>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_DataConnection(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL put_DataConnection(void* value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRealtimeMediaPlayer>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL InitAsync(void* connection, void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL Play(winrt::hresult* result) noexcept = 0;
    virtual int32_t WINRT_CALL Pause(winrt::hresult* result) noexcept = 0;
    virtual int32_t WINRT_CALL Stop(winrt::hresult* result) noexcept = 0;
    virtual int32_t WINRT_CALL add_Closed(void* handler, winrt::event_token* token) noexcept = 0;
    virtual int32_t WINRT_CALL remove_Closed(winrt::event_token token) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRealtimeMediaSource>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL InitAsync(void* connection, void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL get_MediaStreamSource(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_VideoProperties(void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRealtimeServer>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL WriteFrame(uint32_t bufferSize, uint32_t __pBufferSize, uint8_t* pBuffer) noexcept = 0;
    virtual int32_t WINRT_CALL get_VideoProperties(void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRealtimeServerFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(void* connection, winrt::guid inputMediaType, void* mediaEncodingProperties, void** value) noexcept = 0;
};};

template <typename D>
struct consume_RealtimeStreaming_Media_INetworkMediaSink
{
    winrt::event_token Closed(Windows::Foundation::EventHandler<bool> const& handler) const;
    using Closed_revoker = impl::event_revoker<RealtimeStreaming::Media::INetworkMediaSink, &impl::abi_t<RealtimeStreaming::Media::INetworkMediaSink>::remove_Closed>;
    Closed_revoker Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const;
    void Closed(winrt::event_token const& token) const noexcept;
    winrt::hresult OnEndOfStream(uint32_t streamId) const;
};
template <> struct consume<RealtimeStreaming::Media::INetworkMediaSink> { template <typename D> using type = consume_RealtimeStreaming_Media_INetworkMediaSink<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_INetworkMediaSinkFactory
{
    RealtimeStreaming::Media::NetworkMediaSink CreateInstance(RealtimeStreaming::Network::Connection const& connection) const;
};
template <> struct consume<RealtimeStreaming::Media::INetworkMediaSinkFactory> { template <typename D> using type = consume_RealtimeStreaming_Media_INetworkMediaSinkFactory<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_INetworkMediaSinkStream
{
    winrt::hresult Start(int64_t start) const;
    winrt::hresult Restart() const;
    winrt::hresult Stop() const;
    winrt::hresult Pause() const;
    winrt::hresult Shutdown() const;
};
template <> struct consume<RealtimeStreaming::Media::INetworkMediaSinkStream> { template <typename D> using type = consume_RealtimeStreaming_Media_INetworkMediaSinkStream<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_INetworkMediaSinkStreamFactory
{
    RealtimeStreaming::Media::NetworkMediaSinkStream CreateInstance(uint32_t streamId, RealtimeStreaming::Network::Connection const& dataConnection, RealtimeStreaming::Media::NetworkMediaSink const& parentMediaSink) const;
};
template <> struct consume<RealtimeStreaming::Media::INetworkMediaSinkStreamFactory> { template <typename D> using type = consume_RealtimeStreaming_Media_INetworkMediaSinkStreamFactory<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRTSchemeHandler
{
    RealtimeStreaming::Network::Connection DataConnection() const;
    void DataConnection(RealtimeStreaming::Network::Connection const& value) const;
};
template <> struct consume<RealtimeStreaming::Media::IRTSchemeHandler> { template <typename D> using type = consume_RealtimeStreaming_Media_IRTSchemeHandler<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRealtimeMediaPlayer
{
    Windows::Foundation::IAsyncOperation<Windows::Media::MediaProperties::VideoEncodingProperties> InitAsync(RealtimeStreaming::Network::Connection const& connection) const;
    winrt::hresult Play() const;
    winrt::hresult Pause() const;
    winrt::hresult Stop() const;
    winrt::event_token Closed(Windows::Foundation::EventHandler<RealtimeStreaming::Media::RealtimeMediaPlayer> const& handler) const;
    using Closed_revoker = impl::event_revoker<RealtimeStreaming::Media::IRealtimeMediaPlayer, &impl::abi_t<RealtimeStreaming::Media::IRealtimeMediaPlayer>::remove_Closed>;
    Closed_revoker Closed(auto_revoke_t, Windows::Foundation::EventHandler<RealtimeStreaming::Media::RealtimeMediaPlayer> const& handler) const;
    void Closed(winrt::event_token const& token) const noexcept;
};
template <> struct consume<RealtimeStreaming::Media::IRealtimeMediaPlayer> { template <typename D> using type = consume_RealtimeStreaming_Media_IRealtimeMediaPlayer<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRealtimeMediaSource
{
    Windows::Foundation::IAsyncAction InitAsync(RealtimeStreaming::Network::Connection const& connection) const;
    Windows::Media::Core::MediaStreamSource MediaStreamSource() const;
    Windows::Media::MediaProperties::VideoEncodingProperties VideoProperties() const;
};
template <> struct consume<RealtimeStreaming::Media::IRealtimeMediaSource> { template <typename D> using type = consume_RealtimeStreaming_Media_IRealtimeMediaSource<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRealtimeServer
{
    void WriteFrame(uint32_t bufferSize, array_view<uint8_t const> pBuffer) const;
    Windows::Media::MediaProperties::VideoEncodingProperties VideoProperties() const;
};
template <> struct consume<RealtimeStreaming::Media::IRealtimeServer> { template <typename D> using type = consume_RealtimeStreaming_Media_IRealtimeServer<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRealtimeServerFactory
{
    RealtimeStreaming::Media::RealtimeServer CreateInstance(RealtimeStreaming::Network::Connection const& connection, winrt::guid const& inputMediaType, Windows::Media::MediaProperties::MediaEncodingProfile const& mediaEncodingProperties) const;
};
template <> struct consume<RealtimeStreaming::Media::IRealtimeServerFactory> { template <typename D> using type = consume_RealtimeStreaming_Media_IRealtimeServerFactory<D>; };

}
