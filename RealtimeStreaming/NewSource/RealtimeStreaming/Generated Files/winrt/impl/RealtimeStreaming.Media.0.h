// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180227.3

#pragma once

WINRT_EXPORT namespace winrt::RealtimeStreaming::Network {

struct Connection;

}

WINRT_EXPORT namespace winrt::Windows::Foundation::Collections {

struct IPropertySet;

}

WINRT_EXPORT namespace winrt::Windows::Media::Core {

struct MediaStreamSource;

}

WINRT_EXPORT namespace winrt::Windows::Media::MediaProperties {

struct MediaEncodingProfile;
struct VideoEncodingProperties;

}

WINRT_EXPORT namespace winrt::RealtimeStreaming::Media {

enum class SinkStreamOperation : int32_t
{
    SetMediaType = 0,
    Start = 1,
    Restart = 2,
    Pause = 3,
    Stop = 4,
    ProcessSample = 5,
    PlaceMarker = 6,
    Count = 7,
};

enum class SinkStreamState : int32_t
{
    NotSet = 0,
    Ready = 1,
    Started = 2,
    Stopped = 3,
    Paused = 4,
    Count = 5,
};

enum class SourceStreamState : int32_t
{
    Invalid = 0,
    Opening = 1,
    Starting = 2,
    Started = 3,
    Stopped = 4,
    Shutdown = 5,
    Count = 6,
};

struct INetworkMediaSink;
struct INetworkMediaSinkStream;
struct IRealtimeMediaSource;
struct IRealtimeServer;
struct IRealtimeServerFactory;
struct NetworkMediaSink;
struct NetworkMediaSinkStream;
struct RealtimeMediaSource;
struct RealtimeServer;

}

namespace winrt::impl {

template <> struct category<RealtimeStreaming::Media::INetworkMediaSink>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::INetworkMediaSinkStream>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRealtimeMediaSource>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRealtimeServer>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::IRealtimeServerFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Media::NetworkMediaSink>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::NetworkMediaSinkStream>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::RealtimeMediaSource>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::RealtimeServer>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Media::SinkStreamOperation>{ using type = enum_category; };
template <> struct category<RealtimeStreaming::Media::SinkStreamState>{ using type = enum_category; };
template <> struct category<RealtimeStreaming::Media::SourceStreamState>{ using type = enum_category; };
template <> struct name<RealtimeStreaming::Media::INetworkMediaSink>{ static constexpr auto & value{ L"RealtimeStreaming.Media.INetworkMediaSink" }; };
template <> struct name<RealtimeStreaming::Media::INetworkMediaSinkStream>{ static constexpr auto & value{ L"RealtimeStreaming.Media.INetworkMediaSinkStream" }; };
template <> struct name<RealtimeStreaming::Media::IRealtimeMediaSource>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRealtimeMediaSource" }; };
template <> struct name<RealtimeStreaming::Media::IRealtimeServer>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRealtimeServer" }; };
template <> struct name<RealtimeStreaming::Media::IRealtimeServerFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Media.IRealtimeServerFactory" }; };
template <> struct name<RealtimeStreaming::Media::NetworkMediaSink>{ static constexpr auto & value{ L"RealtimeStreaming.Media.NetworkMediaSink" }; };
template <> struct name<RealtimeStreaming::Media::NetworkMediaSinkStream>{ static constexpr auto & value{ L"RealtimeStreaming.Media.NetworkMediaSinkStream" }; };
template <> struct name<RealtimeStreaming::Media::RealtimeMediaSource>{ static constexpr auto & value{ L"RealtimeStreaming.Media.RealtimeMediaSource" }; };
template <> struct name<RealtimeStreaming::Media::RealtimeServer>{ static constexpr auto & value{ L"RealtimeStreaming.Media.RealtimeServer" }; };
template <> struct name<RealtimeStreaming::Media::SinkStreamOperation>{ static constexpr auto & value{ L"RealtimeStreaming.Media.SinkStreamOperation" }; };
template <> struct name<RealtimeStreaming::Media::SinkStreamState>{ static constexpr auto & value{ L"RealtimeStreaming.Media.SinkStreamState" }; };
template <> struct name<RealtimeStreaming::Media::SourceStreamState>{ static constexpr auto & value{ L"RealtimeStreaming.Media.SourceStreamState" }; };
template <> struct guid<RealtimeStreaming::Media::INetworkMediaSink>{ static constexpr GUID value{ 0x35D3F60F,0xFA0D,0x53BC,{ 0x8D,0x53,0x7F,0x96,0xB7,0xE9,0x23,0x49 } }; };
template <> struct guid<RealtimeStreaming::Media::INetworkMediaSinkStream>{ static constexpr GUID value{ 0x98D2B666,0xDBD9,0x5DEF,{ 0x8C,0x8A,0x75,0x2C,0x47,0x68,0x3A,0x7A } }; };
template <> struct guid<RealtimeStreaming::Media::IRealtimeMediaSource>{ static constexpr GUID value{ 0x03F7C586,0x1504,0x5810,{ 0xAB,0x3A,0x7A,0x74,0xC9,0x9B,0x19,0x8D } }; };
template <> struct guid<RealtimeStreaming::Media::IRealtimeServer>{ static constexpr GUID value{ 0xBDF2A077,0x3916,0x5DE4,{ 0xB9,0xEA,0x74,0xF0,0x26,0xB0,0x59,0xD5 } }; };
template <> struct guid<RealtimeStreaming::Media::IRealtimeServerFactory>{ static constexpr GUID value{ 0x5346B092,0x8689,0x54DD,{ 0xAC,0x7A,0xED,0x45,0x75,0xCB,0x1B,0x98 } }; };
template <> struct default_interface<RealtimeStreaming::Media::NetworkMediaSink>{ using type = RealtimeStreaming::Media::INetworkMediaSink; };
template <> struct default_interface<RealtimeStreaming::Media::NetworkMediaSinkStream>{ using type = RealtimeStreaming::Media::INetworkMediaSinkStream; };
template <> struct default_interface<RealtimeStreaming::Media::RealtimeMediaSource>{ using type = RealtimeStreaming::Media::IRealtimeMediaSource; };
template <> struct default_interface<RealtimeStreaming::Media::RealtimeServer>{ using type = RealtimeStreaming::Media::IRealtimeServer; };

template <typename D>
struct consume_RealtimeStreaming_Media_INetworkMediaSink
{
    event_token Closed(Windows::Foundation::EventHandler<bool> const& handler) const;
    using Closed_revoker = event_revoker<RealtimeStreaming::Media::INetworkMediaSink>;
    Closed_revoker Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const;
    void Closed(event_token const& token) const;
    HRESULT OnEndOfStream(uint32_t streamId) const;
    HRESULT HandleError(HRESULT const& hr) const;
    HRESULT CheckShutdown() const;
    HRESULT SendDescription() const;
};
template <> struct consume<RealtimeStreaming::Media::INetworkMediaSink> { template <typename D> using type = consume_RealtimeStreaming_Media_INetworkMediaSink<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_INetworkMediaSinkStream
{
    HRESULT Start(int64_t start) const;
    HRESULT Restart() const;
    HRESULT Stop() const;
    HRESULT Pause() const;
    HRESULT Shutdown() const;
};
template <> struct consume<RealtimeStreaming::Media::INetworkMediaSinkStream> { template <typename D> using type = consume_RealtimeStreaming_Media_INetworkMediaSinkStream<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRealtimeMediaSource
{
    Windows::Foundation::IAsyncAction InitAsync(RealtimeStreaming::Network::Connection const& connection) const;
    Windows::Media::Core::MediaStreamSource MediaStreamSource() const;
    Windows::Media::MediaProperties::VideoEncodingProperties VideoProperties() const;
};
template <> struct consume<RealtimeStreaming::Media::IRealtimeMediaSource> { template <typename D> using type = consume_RealtimeStreaming_Media_IRealtimeMediaSource<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRealtimeServer
{
    void WriteFrame(uint32_t bufferSize, array_view<uint8_t const> pBuffer) const;
    Windows::Media::MediaProperties::VideoEncodingProperties VideoProperties() const;
};
template <> struct consume<RealtimeStreaming::Media::IRealtimeServer> { template <typename D> using type = consume_RealtimeStreaming_Media_IRealtimeServer<D>; };

template <typename D>
struct consume_RealtimeStreaming_Media_IRealtimeServerFactory
{
    RealtimeStreaming::Media::RealtimeServer CreateInstance(RealtimeStreaming::Network::Connection const& connection, GUID const& inputMediaType, Windows::Media::MediaProperties::MediaEncodingProfile const& mediaEncodingProperties) const;
};
template <> struct consume<RealtimeStreaming::Media::IRealtimeServerFactory> { template <typename D> using type = consume_RealtimeStreaming_Media_IRealtimeServerFactory<D>; };

template <> struct abi<RealtimeStreaming::Media::INetworkMediaSink>{ struct type : IInspectable
{
    virtual HRESULT __stdcall add_Closed(void* handler, event_token* token) noexcept = 0;
    virtual HRESULT __stdcall remove_Closed(event_token token) noexcept = 0;
    virtual HRESULT __stdcall OnEndOfStream(uint32_t streamId, HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall HandleError(HRESULT hr, HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall CheckShutdown(HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall SendDescription(HRESULT* result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::INetworkMediaSinkStream>{ struct type : IInspectable
{
    virtual HRESULT __stdcall Start(int64_t start, HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall Restart(HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall Stop(HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall Pause(HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall Shutdown(HRESULT* result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRealtimeMediaSource>{ struct type : IInspectable
{
    virtual HRESULT __stdcall InitAsync(void* connection, void** operation) noexcept = 0;
    virtual HRESULT __stdcall get_MediaStreamSource(void** result) noexcept = 0;
    virtual HRESULT __stdcall get_VideoProperties(void** result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRealtimeServer>{ struct type : IInspectable
{
    virtual HRESULT __stdcall WriteFrame(uint32_t bufferSize, uint32_t __pBufferSize, uint8_t* pBuffer) noexcept = 0;
    virtual HRESULT __stdcall get_VideoProperties(void** result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Media::IRealtimeServerFactory>{ struct type : IInspectable
{
    virtual HRESULT __stdcall CreateInstance(void* connection, GUID inputMediaType, void* mediaEncodingProperties, void** value) noexcept = 0;
};};

}
