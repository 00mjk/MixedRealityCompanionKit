// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180227.3

#pragma once

WINRT_EXPORT namespace winrt::RealtimeStreaming::Common {

enum class PayloadType;

}

WINRT_EXPORT namespace winrt::Windows::Networking::Sockets {

struct StreamSocketInformation;

}

WINRT_EXPORT namespace winrt::RealtimeStreaming::Network {

struct IBundleReceivedArgs;
struct IConnection;
struct IConnector;
struct IDataBuffer;
struct IDataBufferFactory;
struct IDataBundle;
struct IDataBundleFactory;
struct IListener;
struct IListenerFactory;
struct BundleReceivedArgs;
struct Connection;
struct Connector;
struct DataBuffer;
struct DataBundle;
struct Listener;
struct DisconnectedDelegate;

}

namespace winrt::impl {

template <> struct category<RealtimeStreaming::Network::IBundleReceivedArgs>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IConnection>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IConnector>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBuffer>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBufferFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBundle>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBundleFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IListener>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IListenerFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::BundleReceivedArgs>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::Connection>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::Connector>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::DataBuffer>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::DataBundle>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::Listener>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::DisconnectedDelegate>{ using type = delegate_category; };
template <> struct name<RealtimeStreaming::Network::IBundleReceivedArgs>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IBundleReceivedArgs" }; };
template <> struct name<RealtimeStreaming::Network::IConnection>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IConnection" }; };
template <> struct name<RealtimeStreaming::Network::IConnector>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IConnector" }; };
template <> struct name<RealtimeStreaming::Network::IDataBuffer>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBuffer" }; };
template <> struct name<RealtimeStreaming::Network::IDataBufferFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBufferFactory" }; };
template <> struct name<RealtimeStreaming::Network::IDataBundle>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBundle" }; };
template <> struct name<RealtimeStreaming::Network::IDataBundleFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBundleFactory" }; };
template <> struct name<RealtimeStreaming::Network::IListener>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IListener" }; };
template <> struct name<RealtimeStreaming::Network::IListenerFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IListenerFactory" }; };
template <> struct name<RealtimeStreaming::Network::BundleReceivedArgs>{ static constexpr auto & value{ L"RealtimeStreaming.Network.BundleReceivedArgs" }; };
template <> struct name<RealtimeStreaming::Network::Connection>{ static constexpr auto & value{ L"RealtimeStreaming.Network.Connection" }; };
template <> struct name<RealtimeStreaming::Network::Connector>{ static constexpr auto & value{ L"RealtimeStreaming.Network.Connector" }; };
template <> struct name<RealtimeStreaming::Network::DataBuffer>{ static constexpr auto & value{ L"RealtimeStreaming.Network.DataBuffer" }; };
template <> struct name<RealtimeStreaming::Network::DataBundle>{ static constexpr auto & value{ L"RealtimeStreaming.Network.DataBundle" }; };
template <> struct name<RealtimeStreaming::Network::Listener>{ static constexpr auto & value{ L"RealtimeStreaming.Network.Listener" }; };
template <> struct name<RealtimeStreaming::Network::DisconnectedDelegate>{ static constexpr auto & value{ L"RealtimeStreaming.Network.DisconnectedDelegate" }; };
template <> struct guid<RealtimeStreaming::Network::IBundleReceivedArgs>{ static constexpr GUID value{ 0x26A177FE,0x2E53,0x11E9,{ 0xB2,0x10,0xD6,0x63,0xBD,0x87,0x3D,0x93 } }; };
template <> struct guid<RealtimeStreaming::Network::IConnection>{ static constexpr GUID value{ 0xC3D6AC27,0xE622,0x5C29,{ 0x99,0xE6,0xD9,0xE6,0x46,0xA4,0x93,0x7C } }; };
template <> struct guid<RealtimeStreaming::Network::IConnector>{ static constexpr GUID value{ 0xED572D29,0x652C,0x582E,{ 0x9E,0x69,0x13,0x4C,0xE9,0x03,0x3D,0xF7 } }; };
template <> struct guid<RealtimeStreaming::Network::IDataBuffer>{ static constexpr GUID value{ 0x9C3E8BDB,0x28C3,0x5A16,{ 0x86,0x88,0x85,0xEA,0x99,0x44,0x38,0x47 } }; };
template <> struct guid<RealtimeStreaming::Network::IDataBufferFactory>{ static constexpr GUID value{ 0x6AC59985,0xEC6A,0x5753,{ 0xAA,0x3F,0x9E,0x45,0x71,0x7B,0xDA,0x8B } }; };
template <> struct guid<RealtimeStreaming::Network::IDataBundle>{ static constexpr GUID value{ 0x01458CE6,0x2E5F,0x11E9,{ 0xB2,0x10,0xD6,0x63,0xBD,0x87,0x3D,0x93 } }; };
template <> struct guid<RealtimeStreaming::Network::IDataBundleFactory>{ static constexpr GUID value{ 0x042B0FBC,0x2E5F,0x11E9,{ 0xB2,0x10,0xD6,0x63,0xBD,0x87,0x3D,0x93 } }; };
template <> struct guid<RealtimeStreaming::Network::IListener>{ static constexpr GUID value{ 0x4742583B,0x5E91,0x5304,{ 0x8B,0x7A,0xBB,0xC5,0xA8,0xF8,0x62,0x28 } }; };
template <> struct guid<RealtimeStreaming::Network::IListenerFactory>{ static constexpr GUID value{ 0x40793CB7,0x87DB,0x5179,{ 0xBF,0x3B,0x0B,0xB5,0x03,0xDC,0x8B,0xB8 } }; };
template <> struct guid<RealtimeStreaming::Network::DisconnectedDelegate>{ static constexpr GUID value{ 0x93B1EF4F,0x4380,0x5D20,{ 0xBE,0x58,0xC1,0x49,0x72,0x9F,0xB2,0xCA } }; };
template <> struct default_interface<RealtimeStreaming::Network::BundleReceivedArgs>{ using type = RealtimeStreaming::Network::IBundleReceivedArgs; };
template <> struct default_interface<RealtimeStreaming::Network::Connection>{ using type = RealtimeStreaming::Network::IConnection; };
template <> struct default_interface<RealtimeStreaming::Network::Connector>{ using type = RealtimeStreaming::Network::IConnector; };
template <> struct default_interface<RealtimeStreaming::Network::DataBuffer>{ using type = RealtimeStreaming::Network::IDataBuffer; };
template <> struct default_interface<RealtimeStreaming::Network::DataBundle>{ using type = RealtimeStreaming::Network::IDataBundle; };
template <> struct default_interface<RealtimeStreaming::Network::Listener>{ using type = RealtimeStreaming::Network::IListener; };

template <typename D>
struct consume_RealtimeStreaming_Network_IBundleReceivedArgs
{
    RealtimeStreaming::Common::PayloadType PayloadType() const;
    RealtimeStreaming::Network::Connection DataConnection() const;
    RealtimeStreaming::Network::DataBundle Bundle() const;
};
template <> struct consume<RealtimeStreaming::Network::IBundleReceivedArgs> { template <typename D> using type = consume_RealtimeStreaming_Network_IBundleReceivedArgs<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IConnection
{
    Windows::Foundation::IAsyncAction SendPayloadTypeAsync(RealtimeStreaming::Common::PayloadType const& type) const;
    Windows::Foundation::IAsyncAction SendBundleAsync(RealtimeStreaming::Network::DataBundle const& dataBundle) const;
    bool IsConnected() const;
    Windows::Networking::Sockets::StreamSocketInformation ConnectionInfo() const;
    event_token Disconnected(RealtimeStreaming::Network::DisconnectedDelegate const& handler) const;
    using Disconnected_revoker = event_revoker<RealtimeStreaming::Network::IConnection>;
    Disconnected_revoker Disconnected(auto_revoke_t, RealtimeStreaming::Network::DisconnectedDelegate const& handler) const;
    void Disconnected(event_token const& token) const;
    event_token Received(Windows::Foundation::EventHandler<RealtimeStreaming::Network::BundleReceivedArgs> const& handler) const;
    using Received_revoker = event_revoker<RealtimeStreaming::Network::IConnection>;
    Received_revoker Received(auto_revoke_t, Windows::Foundation::EventHandler<RealtimeStreaming::Network::BundleReceivedArgs> const& handler) const;
    void Received(event_token const& token) const;
};
template <> struct consume<RealtimeStreaming::Network::IConnection> { template <typename D> using type = consume_RealtimeStreaming_Network_IConnection<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IConnector
{
    Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> ConnectAsync() const;
    event_token Closed(Windows::Foundation::EventHandler<bool> const& handler) const;
    using Closed_revoker = event_revoker<RealtimeStreaming::Network::IConnector>;
    Closed_revoker Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const;
    void Closed(event_token const& token) const;
};
template <> struct consume<RealtimeStreaming::Network::IConnector> { template <typename D> using type = consume_RealtimeStreaming_Network_IConnector<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBuffer
{
    uint64_t CurrentLength() const;
    void CurrentLength(uint64_t value) const;
    uint64_t Offset() const;
    void Offset(uint64_t value) const;
    HRESULT TrimLeft(uint64_t cbSize) const;
    RealtimeStreaming::Network::DataBuffer TrimRight(uint64_t cbSize) const;
    HRESULT Reset() const;
};
template <> struct consume<RealtimeStreaming::Network::IDataBuffer> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBuffer<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBufferFactory
{
    RealtimeStreaming::Network::DataBuffer CreateInstance(uint64_t size) const;
};
template <> struct consume<RealtimeStreaming::Network::IDataBufferFactory> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBufferFactory<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBundle
{
    uint32_t BufferCount() const;
    uint64_t TotalSize() const;
    void AddBuffer(RealtimeStreaming::Network::DataBuffer const& dataBuffer) const;
    bool InsertBuffer(uint32_t index, RealtimeStreaming::Network::DataBuffer const& dataBuffer) const;
    bool RemoveBuffer(RealtimeStreaming::Network::DataBuffer const& dataBuffer) const;
    void Reset() const;
};
template <> struct consume<RealtimeStreaming::Network::IDataBundle> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBundle<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBundleFactory
{
};
template <> struct consume<RealtimeStreaming::Network::IDataBundleFactory> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBundleFactory<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IListener
{
    Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> ListenAsync() const;
    event_token Closed(Windows::Foundation::EventHandler<bool> const& handler) const;
    using Closed_revoker = event_revoker<RealtimeStreaming::Network::IListener>;
    Closed_revoker Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const;
    void Closed(event_token const& token) const;
};
template <> struct consume<RealtimeStreaming::Network::IListener> { template <typename D> using type = consume_RealtimeStreaming_Network_IListener<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IListenerFactory
{
    RealtimeStreaming::Network::Listener CreateInstance(uint16_t port) const;
};
template <> struct consume<RealtimeStreaming::Network::IListenerFactory> { template <typename D> using type = consume_RealtimeStreaming_Network_IListenerFactory<D>; };

template <> struct abi<RealtimeStreaming::Network::IBundleReceivedArgs>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_PayloadType(RealtimeStreaming::Common::PayloadType* result) noexcept = 0;
    virtual HRESULT __stdcall get_DataConnection(void** result) noexcept = 0;
    virtual HRESULT __stdcall get_Bundle(void** result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IConnection>{ struct type : IInspectable
{
    virtual HRESULT __stdcall SendPayloadTypeAsync(RealtimeStreaming::Common::PayloadType type, void** operation) noexcept = 0;
    virtual HRESULT __stdcall SendBundleAsync(void* dataBundle, void** operation) noexcept = 0;
    virtual HRESULT __stdcall get_IsConnected(bool* result) noexcept = 0;
    virtual HRESULT __stdcall get_ConnectionInfo(void** result) noexcept = 0;
    virtual HRESULT __stdcall add_Disconnected(void* handler, event_token* token) noexcept = 0;
    virtual HRESULT __stdcall remove_Disconnected(event_token token) noexcept = 0;
    virtual HRESULT __stdcall add_Received(void* handler, event_token* token) noexcept = 0;
    virtual HRESULT __stdcall remove_Received(event_token token) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IConnector>{ struct type : IInspectable
{
    virtual HRESULT __stdcall ConnectAsync(void** operation) noexcept = 0;
    virtual HRESULT __stdcall add_Closed(void* handler, event_token* token) noexcept = 0;
    virtual HRESULT __stdcall remove_Closed(event_token token) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBuffer>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_CurrentLength(uint64_t* result) noexcept = 0;
    virtual HRESULT __stdcall put_CurrentLength(uint64_t value) noexcept = 0;
    virtual HRESULT __stdcall get_Offset(uint64_t* result) noexcept = 0;
    virtual HRESULT __stdcall put_Offset(uint64_t value) noexcept = 0;
    virtual HRESULT __stdcall TrimLeft(uint64_t cbSize, HRESULT* result) noexcept = 0;
    virtual HRESULT __stdcall TrimRight(uint64_t cbSize, void** result) noexcept = 0;
    virtual HRESULT __stdcall Reset(HRESULT* result) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBufferFactory>{ struct type : IInspectable
{
    virtual HRESULT __stdcall CreateInstance(uint64_t size, void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBundle>{ struct type : IInspectable
{
    virtual HRESULT __stdcall get_BufferCount(uint32_t* result) noexcept = 0;
    virtual HRESULT __stdcall get_TotalSize(uint64_t* result) noexcept = 0;
    virtual HRESULT __stdcall AddBuffer(void* dataBuffer) noexcept = 0;
    virtual HRESULT __stdcall InsertBuffer(uint32_t index, void* dataBuffer, bool* result) noexcept = 0;
    virtual HRESULT __stdcall RemoveBuffer(void* dataBuffer, bool* result) noexcept = 0;
    virtual HRESULT __stdcall Reset() noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBundleFactory>{ struct type : IInspectable
{
};};

template <> struct abi<RealtimeStreaming::Network::IListener>{ struct type : IInspectable
{
    virtual HRESULT __stdcall ListenAsync(void** operation) noexcept = 0;
    virtual HRESULT __stdcall add_Closed(void* handler, event_token* token) noexcept = 0;
    virtual HRESULT __stdcall remove_Closed(event_token token) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IListenerFactory>{ struct type : IInspectable
{
    virtual HRESULT __stdcall CreateInstance(uint16_t port, void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::DisconnectedDelegate>{ struct type : IUnknown
{
    virtual HRESULT __stdcall Invoke() noexcept = 0;
};};

}
