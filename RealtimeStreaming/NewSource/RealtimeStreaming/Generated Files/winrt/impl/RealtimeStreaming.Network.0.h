// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.180821.2

#pragma once

WINRT_EXPORT namespace winrt::RealtimeStreaming::Common {

enum class PayloadType;

}

WINRT_EXPORT namespace winrt::Windows::Networking::Sockets {

struct StreamSocket;
struct StreamSocketInformation;

}

WINRT_EXPORT namespace winrt::RealtimeStreaming::Network {

struct IConnection;
struct IConnectionFactory;
struct IConnector;
struct IDataBuffer;
struct IDataBufferFactory;
struct IDataBundle;
struct IDataBundleArgs;
struct IDataBundleFactory;
struct IListener;
struct IListenerFactory;
struct Connection;
struct Connector;
struct DataBuffer;
struct DataBundle;
struct DataBundleArgs;
struct Listener;
struct DisconnectedDelegate;

}

namespace winrt::impl {

template <> struct category<RealtimeStreaming::Network::IConnection>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IConnectionFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IConnector>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBuffer>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBufferFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBundle>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBundleArgs>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IDataBundleFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IListener>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::IListenerFactory>{ using type = interface_category; };
template <> struct category<RealtimeStreaming::Network::Connection>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::Connector>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::DataBuffer>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::DataBundle>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::DataBundleArgs>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::Listener>{ using type = class_category; };
template <> struct category<RealtimeStreaming::Network::DisconnectedDelegate>{ using type = delegate_category; };
template <> struct name<RealtimeStreaming::Network::IConnection>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IConnection" }; };
template <> struct name<RealtimeStreaming::Network::IConnectionFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IConnectionFactory" }; };
template <> struct name<RealtimeStreaming::Network::IConnector>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IConnector" }; };
template <> struct name<RealtimeStreaming::Network::IDataBuffer>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBuffer" }; };
template <> struct name<RealtimeStreaming::Network::IDataBufferFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBufferFactory" }; };
template <> struct name<RealtimeStreaming::Network::IDataBundle>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBundle" }; };
template <> struct name<RealtimeStreaming::Network::IDataBundleArgs>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBundleArgs" }; };
template <> struct name<RealtimeStreaming::Network::IDataBundleFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IDataBundleFactory" }; };
template <> struct name<RealtimeStreaming::Network::IListener>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IListener" }; };
template <> struct name<RealtimeStreaming::Network::IListenerFactory>{ static constexpr auto & value{ L"RealtimeStreaming.Network.IListenerFactory" }; };
template <> struct name<RealtimeStreaming::Network::Connection>{ static constexpr auto & value{ L"RealtimeStreaming.Network.Connection" }; };
template <> struct name<RealtimeStreaming::Network::Connector>{ static constexpr auto & value{ L"RealtimeStreaming.Network.Connector" }; };
template <> struct name<RealtimeStreaming::Network::DataBuffer>{ static constexpr auto & value{ L"RealtimeStreaming.Network.DataBuffer" }; };
template <> struct name<RealtimeStreaming::Network::DataBundle>{ static constexpr auto & value{ L"RealtimeStreaming.Network.DataBundle" }; };
template <> struct name<RealtimeStreaming::Network::DataBundleArgs>{ static constexpr auto & value{ L"RealtimeStreaming.Network.DataBundleArgs" }; };
template <> struct name<RealtimeStreaming::Network::Listener>{ static constexpr auto & value{ L"RealtimeStreaming.Network.Listener" }; };
template <> struct name<RealtimeStreaming::Network::DisconnectedDelegate>{ static constexpr auto & value{ L"RealtimeStreaming.Network.DisconnectedDelegate" }; };
template <> struct guid_storage<RealtimeStreaming::Network::IConnection>{ static constexpr guid value{ 0x27487688,0x8BB0,0x5355,{ 0xBC,0x5F,0xB8,0x65,0xE2,0x1E,0x94,0x8A } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IConnectionFactory>{ static constexpr guid value{ 0x14F9460A,0x72AC,0x5AF7,{ 0xAC,0xA4,0xF3,0xCA,0xC9,0xB8,0x17,0x7C } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IConnector>{ static constexpr guid value{ 0xED572D29,0x652C,0x582E,{ 0x9E,0x69,0x13,0x4C,0xE9,0x03,0x3D,0xF7 } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IDataBuffer>{ static constexpr guid value{ 0x6658E1FD,0x76CD,0x5705,{ 0x93,0x20,0xFF,0x3D,0xA3,0x47,0xD9,0x1D } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IDataBufferFactory>{ static constexpr guid value{ 0x6AC59985,0xEC6A,0x5753,{ 0xAA,0x3F,0x9E,0x45,0x71,0x7B,0xDA,0x8B } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IDataBundle>{ static constexpr guid value{ 0x01458CE6,0x2E5F,0x11E9,{ 0xB2,0x10,0xD6,0x63,0xBD,0x87,0x3D,0x93 } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IDataBundleArgs>{ static constexpr guid value{ 0x26A177FE,0x2E53,0x11E9,{ 0xB2,0x10,0xD6,0x63,0xBD,0x87,0x3D,0x93 } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IDataBundleFactory>{ static constexpr guid value{ 0x042B0FBC,0x2E5F,0x11E9,{ 0xB2,0x10,0xD6,0x63,0xBD,0x87,0x3D,0x93 } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IListener>{ static constexpr guid value{ 0x4742583B,0x5E91,0x5304,{ 0x8B,0x7A,0xBB,0xC5,0xA8,0xF8,0x62,0x28 } }; };
template <> struct guid_storage<RealtimeStreaming::Network::IListenerFactory>{ static constexpr guid value{ 0x40793CB7,0x87DB,0x5179,{ 0xBF,0x3B,0x0B,0xB5,0x03,0xDC,0x8B,0xB8 } }; };
template <> struct guid_storage<RealtimeStreaming::Network::DisconnectedDelegate>{ static constexpr guid value{ 0x93B1EF4F,0x4380,0x5D20,{ 0xBE,0x58,0xC1,0x49,0x72,0x9F,0xB2,0xCA } }; };
template <> struct default_interface<RealtimeStreaming::Network::Connection>{ using type = RealtimeStreaming::Network::IConnection; };
template <> struct default_interface<RealtimeStreaming::Network::Connector>{ using type = RealtimeStreaming::Network::IConnector; };
template <> struct default_interface<RealtimeStreaming::Network::DataBuffer>{ using type = RealtimeStreaming::Network::IDataBuffer; };
template <> struct default_interface<RealtimeStreaming::Network::DataBundle>{ using type = RealtimeStreaming::Network::IDataBundle; };
template <> struct default_interface<RealtimeStreaming::Network::DataBundleArgs>{ using type = RealtimeStreaming::Network::IDataBundleArgs; };
template <> struct default_interface<RealtimeStreaming::Network::Listener>{ using type = RealtimeStreaming::Network::IListener; };

template <> struct abi<RealtimeStreaming::Network::IConnection>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL SendPayloadTypeAsync(RealtimeStreaming::Common::PayloadType type, void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL SendBundleAsync(void* dataBundle, void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL get_IsConnected(bool* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_ConnectionInfo(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL add_Disconnected(void* handler, winrt::event_token* token) noexcept = 0;
    virtual int32_t WINRT_CALL remove_Disconnected(winrt::event_token token) noexcept = 0;
    virtual int32_t WINRT_CALL add_Received(void* handler, winrt::event_token* token) noexcept = 0;
    virtual int32_t WINRT_CALL remove_Received(winrt::event_token token) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IConnectionFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(void* streamSocket, void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IConnector>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL ConnectAsync(void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL add_Closed(void* handler, winrt::event_token* token) noexcept = 0;
    virtual int32_t WINRT_CALL remove_Closed(winrt::event_token token) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBuffer>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_CurrentLength(uint64_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL put_CurrentLength(uint64_t value) noexcept = 0;
    virtual int32_t WINRT_CALL get_Offset(uint64_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL put_Offset(uint64_t value) noexcept = 0;
    virtual int32_t WINRT_CALL TrimLeft(uint64_t cbSize) noexcept = 0;
    virtual int32_t WINRT_CALL TrimRight(uint64_t cbSize, void** result) noexcept = 0;
    virtual int32_t WINRT_CALL Reset() noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBufferFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(uint64_t size, void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBundle>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_BufferCount(uint32_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_TotalSize(uint64_t* value) noexcept = 0;
    virtual int32_t WINRT_CALL AddBuffer(void* dataBuffer) noexcept = 0;
    virtual int32_t WINRT_CALL InsertBuffer(uint32_t index, void* dataBuffer, bool* result) noexcept = 0;
    virtual int32_t WINRT_CALL RemoveBuffer(void* dataBuffer, bool* result) noexcept = 0;
    virtual int32_t WINRT_CALL Reset() noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBundleArgs>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL get_PayloadType(RealtimeStreaming::Common::PayloadType* value) noexcept = 0;
    virtual int32_t WINRT_CALL get_DataConnection(void** value) noexcept = 0;
    virtual int32_t WINRT_CALL get_Bundle(void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IDataBundleFactory>{ struct type : IInspectable
{
};};

template <> struct abi<RealtimeStreaming::Network::IListener>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL ListenAsync(void** operation) noexcept = 0;
    virtual int32_t WINRT_CALL add_Closed(void* handler, winrt::event_token* token) noexcept = 0;
    virtual int32_t WINRT_CALL remove_Closed(winrt::event_token token) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::IListenerFactory>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL CreateInstance(uint16_t port, void** value) noexcept = 0;
};};

template <> struct abi<RealtimeStreaming::Network::DisconnectedDelegate>{ struct type : IUnknown
{
    virtual int32_t WINRT_CALL Invoke() noexcept = 0;
};};

template <typename D>
struct consume_RealtimeStreaming_Network_IConnection
{
    Windows::Foundation::IAsyncAction SendPayloadTypeAsync(RealtimeStreaming::Common::PayloadType const& type) const;
    Windows::Foundation::IAsyncAction SendBundleAsync(RealtimeStreaming::Network::DataBundle const& dataBundle) const;
    bool IsConnected() const;
    Windows::Networking::Sockets::StreamSocketInformation ConnectionInfo() const;
    winrt::event_token Disconnected(RealtimeStreaming::Network::DisconnectedDelegate const& handler) const;
    using Disconnected_revoker = impl::event_revoker<RealtimeStreaming::Network::IConnection, &impl::abi_t<RealtimeStreaming::Network::IConnection>::remove_Disconnected>;
    Disconnected_revoker Disconnected(auto_revoke_t, RealtimeStreaming::Network::DisconnectedDelegate const& handler) const;
    void Disconnected(winrt::event_token const& token) const noexcept;
    winrt::event_token Received(Windows::Foundation::EventHandler<RealtimeStreaming::Network::DataBundleArgs> const& handler) const;
    using Received_revoker = impl::event_revoker<RealtimeStreaming::Network::IConnection, &impl::abi_t<RealtimeStreaming::Network::IConnection>::remove_Received>;
    Received_revoker Received(auto_revoke_t, Windows::Foundation::EventHandler<RealtimeStreaming::Network::DataBundleArgs> const& handler) const;
    void Received(winrt::event_token const& token) const noexcept;
};
template <> struct consume<RealtimeStreaming::Network::IConnection> { template <typename D> using type = consume_RealtimeStreaming_Network_IConnection<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IConnectionFactory
{
    RealtimeStreaming::Network::Connection CreateInstance(Windows::Networking::Sockets::StreamSocket const& streamSocket) const;
};
template <> struct consume<RealtimeStreaming::Network::IConnectionFactory> { template <typename D> using type = consume_RealtimeStreaming_Network_IConnectionFactory<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IConnector
{
    Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> ConnectAsync() const;
    winrt::event_token Closed(Windows::Foundation::EventHandler<bool> const& handler) const;
    using Closed_revoker = impl::event_revoker<RealtimeStreaming::Network::IConnector, &impl::abi_t<RealtimeStreaming::Network::IConnector>::remove_Closed>;
    Closed_revoker Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const;
    void Closed(winrt::event_token const& token) const noexcept;
};
template <> struct consume<RealtimeStreaming::Network::IConnector> { template <typename D> using type = consume_RealtimeStreaming_Network_IConnector<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBuffer
{
    uint64_t CurrentLength() const;
    void CurrentLength(uint64_t value) const;
    uint64_t Offset() const;
    void Offset(uint64_t value) const;
    void TrimLeft(uint64_t cbSize) const;
    RealtimeStreaming::Network::DataBuffer TrimRight(uint64_t cbSize) const;
    void Reset() const;
};
template <> struct consume<RealtimeStreaming::Network::IDataBuffer> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBuffer<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBufferFactory
{
    RealtimeStreaming::Network::DataBuffer CreateInstance(uint64_t size) const;
};
template <> struct consume<RealtimeStreaming::Network::IDataBufferFactory> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBufferFactory<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBundle
{
    uint32_t BufferCount() const;
    uint64_t TotalSize() const;
    void AddBuffer(RealtimeStreaming::Network::DataBuffer const& dataBuffer) const;
    bool InsertBuffer(uint32_t index, RealtimeStreaming::Network::DataBuffer const& dataBuffer) const;
    bool RemoveBuffer(RealtimeStreaming::Network::DataBuffer const& dataBuffer) const;
    void Reset() const;
};
template <> struct consume<RealtimeStreaming::Network::IDataBundle> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBundle<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBundleArgs
{
    RealtimeStreaming::Common::PayloadType PayloadType() const;
    RealtimeStreaming::Network::Connection DataConnection() const;
    RealtimeStreaming::Network::DataBundle Bundle() const;
};
template <> struct consume<RealtimeStreaming::Network::IDataBundleArgs> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBundleArgs<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IDataBundleFactory
{
};
template <> struct consume<RealtimeStreaming::Network::IDataBundleFactory> { template <typename D> using type = consume_RealtimeStreaming_Network_IDataBundleFactory<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IListener
{
    Windows::Foundation::IAsyncOperation<RealtimeStreaming::Network::Connection> ListenAsync() const;
    winrt::event_token Closed(Windows::Foundation::EventHandler<bool> const& handler) const;
    using Closed_revoker = impl::event_revoker<RealtimeStreaming::Network::IListener, &impl::abi_t<RealtimeStreaming::Network::IListener>::remove_Closed>;
    Closed_revoker Closed(auto_revoke_t, Windows::Foundation::EventHandler<bool> const& handler) const;
    void Closed(winrt::event_token const& token) const noexcept;
};
template <> struct consume<RealtimeStreaming::Network::IListener> { template <typename D> using type = consume_RealtimeStreaming_Network_IListener<D>; };

template <typename D>
struct consume_RealtimeStreaming_Network_IListenerFactory
{
    RealtimeStreaming::Network::Listener CreateInstance(uint16_t port) const;
};
template <> struct consume<RealtimeStreaming::Network::IListenerFactory> { template <typename D> using type = consume_RealtimeStreaming_Network_IListenerFactory<D>; };

}
